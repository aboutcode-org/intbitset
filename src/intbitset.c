/* Generated by Cython 0.9.6.7 on Wed Oct 31 14:03:39 2007 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
#endif
#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif
__PYX_EXTERN_C double pow(double, double);
#include "intbitset.h"


#ifdef __GNUC__
#define INLINE __inline__
#elif _WIN32
#define INLINE __inline
#else
#define INLINE 
#endif

typedef struct {const char *s; const void **p;} __Pyx_CApiTabEntry; /*proto*/
typedef struct {PyObject **p; char *s;} __Pyx_InternTabEntry; /*proto*/
typedef struct {PyObject **p; char *s; long n; int is_unicode;} __Pyx_StringTabEntry; /*proto*/

#define __pyx_PyIndex_AsSsize_t(b) PyInt_AsSsize_t(PyNumber_Index(b))

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   if (x == Py_True) return 1;
   else if (x == Py_False) return 0;
   else return PyObject_IsTrue(x);
}


#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static int __pyx_lineno;
static char *__pyx_filename;
static char **__pyx_f;

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed, char *name); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list); /*proto*/

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static PyObject *__Pyx_GetExcValue(void); /*proto*/

static PyObject *__Pyx_UnpackItem(PyObject *); /*proto*/
static int __Pyx_EndUnpack(PyObject *); /*proto*/

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/

static void __Pyx_AddTraceback(char *funcname); /*proto*/

/* Declarations from intbitset */


struct __pyx_obj_9intbitset_intbitset {
  PyObject_HEAD
  IntBitSet (*bitset);
  bool_t sanity_checks;
};


struct __pyx_obj_9intbitset_intbitset_iterator {
  PyObject_HEAD
  int last;
  IntBitSet (*bitset);
};

static PyTypeObject *__pyx_ptype_9intbitset_intbitset = 0;
static PyTypeObject *__pyx_ptype_9intbitset_intbitset_iterator = 0;
static PyObject *__pyx_k8;
static int __pyx_k9;
static int __pyx_k10;
static PyObject *__pyx_k11;
static int __pyx_k12;
static int __pyx_k13;


/* Implementation of intbitset */

static char (__pyx_k1[]) = "$Id$";
static char (__pyx_k2[]) = "\nDefines an intbitset data object to hold unordered sets of unsigned\nintegers with ultra fast set operations, implemented via bit vectors\nand Python C extension to optimize speed and memory usage.\n\nEmulates the Python built-in set class interface with some additional\nspecific methods such as its own fast dump and load marshalling\nfunctions.  Uses real bits to optimize memory usage, so may have\nissues with endianness if you transport serialized bitsets between\nvarious machine architectures.\n\nPlease note that no bigger than __maxelem__ elements can be added to\nan intbitset and, if CFG_INTBITSET_ENABLE_SANITY_CHECKS is disabled,\nyou will receive unpredictable results.\n";
static char (__pyx_k6[]) = "invenio.config";

static PyObject *__pyx_num_0;

static PyObject *__pyx_n___revision__;
static PyObject *__pyx_n___apilevel__;
static PyObject *__pyx_n_zlib;
static PyObject *__pyx_n_array;
static PyObject *__pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS;
static PyObject *__pyx_n___maxelem__;
static PyObject *__pyx_n___new__;
static PyObject *__pyx_n___dealloc__;
static PyObject *__pyx_n___contains__;
static PyObject *__pyx_n___cmp__;
static PyObject *__pyx_n___richcmp__;
static PyObject *__pyx_n___len__;
static PyObject *__pyx_n___hash__;
static PyObject *__pyx_n___nonzero__;
static PyObject *__pyx_n___iadd__;
static PyObject *__pyx_n___isub__;
static PyObject *__pyx_n___deepcopy__;
static PyObject *__pyx_n___del__;
static PyObject *__pyx_n___and__;
static PyObject *__pyx_n___or__;
static PyObject *__pyx_n___xor__;
static PyObject *__pyx_n___sub__;
static PyObject *__pyx_n___iand__;
static PyObject *__pyx_n___ior__;
static PyObject *__pyx_n___ixor__;
static PyObject *__pyx_n___repr__;
static PyObject *__pyx_n___str__;
static PyObject *__pyx_n___iter__;
static PyObject *__pyx_n_add;
static PyObject *__pyx_n_clear;
static PyObject *__pyx_n_difference;
static PyObject *__pyx_n_difference_update;
static PyObject *__pyx_n_discard;
static PyObject *__pyx_n_intersection;
static PyObject *__pyx_n_intersection_update;
static PyObject *__pyx_n_union;
static PyObject *__pyx_n_union_update;
static PyObject *__pyx_n_issubset;
static PyObject *__pyx_n_issuperset;
static PyObject *__pyx_n_symmetric_difference;
static PyObject *__pyx_n_symmetric_difference_update;
static PyObject *__pyx_n_fastdump;
static PyObject *__pyx_n_fastload;
static PyObject *__pyx_n_copy;
static PyObject *__pyx_n_pop;
static PyObject *__pyx_n_remove;
static PyObject *__pyx_n_strbits;
static PyObject *__pyx_n_update_with_signs;
static PyObject *__pyx_n_get_size;
static PyObject *__pyx_n_get_allocated;
static PyObject *__pyx_n_get_sorted_element;
static PyObject *__pyx_n_to_sorted_list;
static PyObject *__pyx_n_is_infinite;
static PyObject *__pyx_n_extract_finite_list;
static PyObject *__pyx_n_get_wordbitsize;
static PyObject *__pyx_n_get_wordbytsize;
static PyObject *__pyx_n_tolist;
static PyObject *__pyx_n___next__;

static PyObject *__pyx_k1p;
static PyObject *__pyx_k6p;

static PyObject *__pyx_n_Error;
static PyObject *__pyx_n_ValueError;
static PyObject *__pyx_n_tostring;
static PyObject *__pyx_n_decompress;
static PyObject *__pyx_n_Exception;
static PyObject *__pyx_n_max;
static PyObject *__pyx_n_OverflowError;
static PyObject *__pyx_n_TypeError;

static PyObject *__pyx_k15p;
static PyObject *__pyx_k16p;
static PyObject *__pyx_k17p;
static PyObject *__pyx_k19p;
static PyObject *__pyx_k20p;
static PyObject *__pyx_k21p;
static PyObject *__pyx_k22p;
static PyObject *__pyx_k23p;
static PyObject *__pyx_k24p;
static PyObject *__pyx_k25p;

static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_max;
static PyObject *__pyx_builtin_OverflowError;
static PyObject *__pyx_builtin_TypeError;

static char (__pyx_k15[]) = "rhs can't be negative";
static char (__pyx_k16[]) = "Buffer error!!!";
static char (__pyx_k17[]) = "rhs is corrupted: %s";
static char (__pyx_k19[]) = "Can't integers bigger than %s";
static char (__pyx_k20[]) = "Negative numbers, not allowed";
static char (__pyx_k21[]) = "Elements must be <= %s";
static char (__pyx_k22[]) = "Negative numbers, not allowed";
static char (__pyx_k23[]) = "Elements must be <= %s";
static char (__pyx_k24[]) = "retrieving integers from rhs is impossible: %s";
static char (__pyx_k25[]) = "rhs is of unknown type %s";

static int __pyx_f_py_9intbitset_9intbitset___new__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9intbitset_9intbitset___new__[] = "\n        Initialize intbitset.\n        * rhs can be:\n         - int/long for creating allocating empty intbitset that will hold at least\n            rhs elements, before being resized\n         - intbitset for cloning\n         - str for retrieving an intbitset that was dumped into a string\n         - array for retrieving an intbitset that was dumped into a string stored\n            in an array\n         - sequence made of integers for copying all the elements from the\n            sequence. If minsize is specified than it is initially allocated\n            enough space to hold up to minsize integers, otherwise the biggest\n            element of the sequence will be used.\n        * preallocate is a suggested initial upper bound on the numbers that will be\n            stored, by looking at rhs a sequence of number.\n        * trailing_bits is 1, then the set will contain \"all\" the positive integers\n        * no_allocate is used internally and should never be set.\n        after the biggest one added with rhs.\n        ";
static int __pyx_f_py_9intbitset_9intbitset___new__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_rhs = 0;
  int __pyx_v_preallocate;
  int __pyx_v_trailing_bits;
  PyObject *__pyx_v_sanity_checks = 0;
  int __pyx_v_no_allocate;
  Py_ssize_t __pyx_v_size;
  void (*__pyx_v_buf);
  int __pyx_v_elem;
  int __pyx_v_last;
  int __pyx_v_remelem;
  PyObject *__pyx_v_msg;
  PyObject *__pyx_v_tmp;
  int __pyx_r;
  bool_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  PyObject *__pyx_6 = 0;
  int __pyx_7;
  Py_ssize_t __pyx_8;
  static char *__pyx_argnames[] = {"rhs","preallocate","trailing_bits","sanity_checks","no_allocate",0};
  __pyx_v_rhs = __pyx_k8;
  __pyx_v_preallocate = __pyx_k9;
  __pyx_v_trailing_bits = __pyx_k10;
  __pyx_v_sanity_checks = __pyx_k11;
  __pyx_v_no_allocate = __pyx_k12;
  if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "|OiiOi", __pyx_argnames, &__pyx_v_rhs, &__pyx_v_preallocate, &__pyx_v_trailing_bits, &__pyx_v_sanity_checks, &__pyx_v_no_allocate))) return -1;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  Py_INCREF(__pyx_v_sanity_checks);
  __pyx_v_msg = Py_None; Py_INCREF(Py_None);
  __pyx_v_tmp = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":133
 *         cdef int last
 *         cdef int remelem
 *         self.sanity_checks = sanity_checks             # <<<<<<<<<<<<<< 
 *         msg = "Error"
 *         self.bitset = NULL
 */
  __pyx_1 = PyInt_AsLong(__pyx_v_sanity_checks); if (unlikely((__pyx_1 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; goto __pyx_L1;}
  ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks = __pyx_1;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":134
 *         cdef int remelem
 *         self.sanity_checks = sanity_checks
 *         msg = "Error"             # <<<<<<<<<<<<<< 
 *         self.bitset = NULL
 *         if no_allocate:
 */
  Py_INCREF(__pyx_n_Error);
  Py_DECREF(__pyx_v_msg);
  __pyx_v_msg = __pyx_n_Error;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":135
 *         self.sanity_checks = sanity_checks
 *         msg = "Error"
 *         self.bitset = NULL             # <<<<<<<<<<<<<< 
 *         if no_allocate:
 *             self.bitset = intBitSetCreateNoAllocate()
 */
  ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset = NULL;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":136
 *         msg = "Error"
 *         self.bitset = NULL
 *         if no_allocate:             # <<<<<<<<<<<<<< 
 *             self.bitset = intBitSetCreateNoAllocate()
 *             return
 */
  __pyx_2 = __pyx_v_no_allocate;
  if (__pyx_2) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":137
 *         self.bitset = NULL
 *         if no_allocate:
 *             self.bitset = intBitSetCreateNoAllocate()             # <<<<<<<<<<<<<< 
 *             return
 *         if type(rhs) in (int, long):
 */
    ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreateNoAllocate();

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":138
 *         if no_allocate:
 *             self.bitset = intBitSetCreateNoAllocate()
 *             return             # <<<<<<<<<<<<<< 
 *         if type(rhs) in (int, long):
 *             if rhs < 0:
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":139
 *             self.bitset = intBitSetCreateNoAllocate()
 *             return
 *         if type(rhs) in (int, long):             # <<<<<<<<<<<<<< 
 *             if rhs < 0:
 *                 raise ValueError, "rhs can't be negative"
 */
  __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 139; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_v_rhs);
  __pyx_4 = PyObject_CallObject(((PyObject*)&PyType_Type), __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 139; goto __pyx_L1;}
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  __pyx_3 = PyTuple_New(2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 139; goto __pyx_L1;}
  Py_INCREF(((PyObject*)&PyInt_Type));
  PyTuple_SET_ITEM(__pyx_3, 0, ((PyObject*)&PyInt_Type));
  Py_INCREF(((PyObject*)&PyLong_Type));
  PyTuple_SET_ITEM(__pyx_3, 1, ((PyObject*)&PyLong_Type));
  __pyx_5 = (PySequence_Contains(__pyx_3, __pyx_4)); if (unlikely(__pyx_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 139; goto __pyx_L1;}
  Py_DECREF(__pyx_4); __pyx_4 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  if (__pyx_5) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":140
 *             return
 *         if type(rhs) in (int, long):
 *             if rhs < 0:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "rhs can't be negative"
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 */
    __pyx_4 = PyObject_RichCompare(__pyx_v_rhs, __pyx_num_0, Py_LT); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; goto __pyx_L1;}
    __pyx_5 = __Pyx_PyObject_IsTrue(__pyx_4); if (unlikely(__pyx_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    if (__pyx_5) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":141
 *         if type(rhs) in (int, long):
 *             if rhs < 0:
 *                 raise ValueError, "rhs can't be negative"             # <<<<<<<<<<<<<< 
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 *         elif type(rhs) is intbitset:
 */
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k15p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; goto __pyx_L1;}
      goto __pyx_L4;
    }
    __pyx_L4:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":142
 *             if rhs < 0:
 *                 raise ValueError, "rhs can't be negative"
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)             # <<<<<<<<<<<<<< 
 *         elif type(rhs) is intbitset:
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)
 */
    __pyx_2 = PyInt_AsLong(__pyx_v_rhs); if (unlikely((__pyx_2 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 142; goto __pyx_L1;}
    ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreate(__pyx_2,__pyx_v_trailing_bits);
    goto __pyx_L3;
  }
  __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_v_rhs);
  __pyx_4 = PyObject_CallObject(((PyObject*)&PyType_Type), __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; goto __pyx_L1;}
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  __pyx_5 = (__pyx_4 == ((PyObject*)__pyx_ptype_9intbitset_intbitset));
  Py_DECREF(__pyx_4); __pyx_4 = 0;
  if (__pyx_5) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":144
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 *         elif type(rhs) is intbitset:
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)             # <<<<<<<<<<<<<< 
 *         elif type(rhs) in (str, array):
 *             try:
 */
    ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetClone(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);
    goto __pyx_L3;
  }
  __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_v_rhs);
  __pyx_4 = PyObject_CallObject(((PyObject*)&PyType_Type), __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; goto __pyx_L1;}
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  __pyx_3 = __Pyx_GetName(__pyx_m, __pyx_n_array); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; goto __pyx_L1;}
  __pyx_6 = PyTuple_New(2); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; goto __pyx_L1;}
  Py_INCREF(((PyObject*)&PyString_Type));
  PyTuple_SET_ITEM(__pyx_6, 0, ((PyObject*)&PyString_Type));
  PyTuple_SET_ITEM(__pyx_6, 1, __pyx_3);
  __pyx_3 = 0;
  __pyx_5 = (PySequence_Contains(__pyx_6, __pyx_4)); if (unlikely(__pyx_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 145; goto __pyx_L1;}
  Py_DECREF(__pyx_4); __pyx_4 = 0;
  Py_DECREF(__pyx_6); __pyx_6 = 0;
  if (__pyx_5) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":146
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)
 *         elif type(rhs) in (str, array):
 *             try:             # <<<<<<<<<<<<<< 
 *                 if type(rhs) is array:
 *                     rhs = rhs.tostring()
 */
    /*try:*/ {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":147
 *         elif type(rhs) in (str, array):
 *             try:
 *                 if type(rhs) is array:             # <<<<<<<<<<<<<< 
 *                     rhs = rhs.tostring()
 *                 tmp = zlib.decompress(rhs)
 */
      __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; goto __pyx_L5;}
      Py_INCREF(__pyx_v_rhs);
      PyTuple_SET_ITEM(__pyx_3, 0, __pyx_v_rhs);
      __pyx_4 = PyObject_CallObject(((PyObject*)&PyType_Type), __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; goto __pyx_L5;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __pyx_6 = __Pyx_GetName(__pyx_m, __pyx_n_array); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; goto __pyx_L5;}
      __pyx_5 = (__pyx_4 == __pyx_6);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      if (__pyx_5) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":148
 *             try:
 *                 if type(rhs) is array:
 *                     rhs = rhs.tostring()             # <<<<<<<<<<<<<< 
 *                 tmp = zlib.decompress(rhs)
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 */
        __pyx_3 = PyObject_GetAttr(__pyx_v_rhs, __pyx_n_tostring); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; goto __pyx_L5;}
        __pyx_4 = PyObject_CallObject(__pyx_3, 0); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; goto __pyx_L5;}
        Py_DECREF(__pyx_3); __pyx_3 = 0;
        Py_DECREF(__pyx_v_rhs);
        __pyx_v_rhs = __pyx_4;
        __pyx_4 = 0;
        goto __pyx_L7;
      }
      __pyx_L7:;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":149
 *                 if type(rhs) is array:
 *                     rhs = rhs.tostring()
 *                 tmp = zlib.decompress(rhs)             # <<<<<<<<<<<<<< 
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                     raise Exception, "Buffer error!!!"
 */
      __pyx_6 = __Pyx_GetName(__pyx_m, __pyx_n_zlib); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; goto __pyx_L5;}
      __pyx_3 = PyObject_GetAttr(__pyx_6, __pyx_n_decompress); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; goto __pyx_L5;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      __pyx_4 = PyTuple_New(1); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; goto __pyx_L5;}
      Py_INCREF(__pyx_v_rhs);
      PyTuple_SET_ITEM(__pyx_4, 0, __pyx_v_rhs);
      __pyx_6 = PyObject_CallObject(__pyx_3, __pyx_4); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; goto __pyx_L5;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      Py_DECREF(__pyx_v_tmp);
      __pyx_v_tmp = __pyx_6;
      __pyx_6 = 0;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":150
 *                     rhs = rhs.tostring()
 *                 tmp = zlib.decompress(rhs)
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:             # <<<<<<<<<<<<<< 
 *                     raise Exception, "Buffer error!!!"
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 */
      __pyx_5 = (PyObject_AsReadBuffer(__pyx_v_tmp,(&__pyx_v_buf),(&__pyx_v_size)) < 0);
      if (__pyx_5) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":151
 *                 tmp = zlib.decompress(rhs)
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                     raise Exception, "Buffer error!!!"             # <<<<<<<<<<<<<< 
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 *             except Exception, msg:
 */
        __Pyx_Raise(__pyx_builtin_Exception, __pyx_k16p, 0);
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; goto __pyx_L5;}
        goto __pyx_L8;
      }
      __pyx_L8:;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":152
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                     raise Exception, "Buffer error!!!"
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)             # <<<<<<<<<<<<<< 
 *             except Exception, msg:
 *                 raise ValueError, "rhs is corrupted: %s" % msg
 */
      ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreateFromBuffer(__pyx_v_buf,__pyx_v_size);
    }
    goto __pyx_L6;
    __pyx_L5:;
    Py_XDECREF(__pyx_3); __pyx_3 = 0;
    Py_XDECREF(__pyx_4); __pyx_4 = 0;
    Py_XDECREF(__pyx_6); __pyx_6 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":153
 *                     raise Exception, "Buffer error!!!"
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 *             except Exception, msg:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "rhs is corrupted: %s" % msg
 *         elif hasattr(rhs, '__iter__'):
 */
    __pyx_2 = PyErr_ExceptionMatches(__pyx_builtin_Exception);
    if (__pyx_2) {
      __Pyx_AddTraceback("intbitset.__new__");
      __pyx_3 = __Pyx_GetExcValue(); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; goto __pyx_L1;}
      Py_DECREF(__pyx_v_msg);
      __pyx_v_msg = __pyx_3;
      __pyx_3 = 0;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":154
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 *             except Exception, msg:
 *                 raise ValueError, "rhs is corrupted: %s" % msg             # <<<<<<<<<<<<<< 
 *         elif hasattr(rhs, '__iter__'):
 *             try:
 */
      __pyx_4 = PyNumber_Remainder(__pyx_k17p, __pyx_v_msg); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; goto __pyx_L1;}
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; goto __pyx_L1;}
      goto __pyx_L6;
    }
    goto __pyx_L1;
    __pyx_L6:;
    goto __pyx_L3;
  }
  __pyx_5 = PyObject_HasAttr(__pyx_v_rhs,__pyx_n___iter__);
  if (__pyx_5) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":156
 *                 raise ValueError, "rhs is corrupted: %s" % msg
 *         elif hasattr(rhs, '__iter__'):
 *             try:             # <<<<<<<<<<<<<< 
 *                 if preallocate < 0:
 *                     if rhs:
 */
    /*try:*/ {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":157
 *         elif hasattr(rhs, '__iter__'):
 *             try:
 *                 if preallocate < 0:             # <<<<<<<<<<<<<< 
 *                     if rhs:
 *                         preallocate = max(rhs)
 */
      __pyx_5 = (__pyx_v_preallocate < 0);
      if (__pyx_5) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":158
 *             try:
 *                 if preallocate < 0:
 *                     if rhs:             # <<<<<<<<<<<<<< 
 *                         preallocate = max(rhs)
 *                     else:
 */
        __pyx_5 = __Pyx_PyObject_IsTrue(__pyx_v_rhs); if (unlikely(__pyx_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; goto __pyx_L9;}
        if (__pyx_5) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":159
 *                 if preallocate < 0:
 *                     if rhs:
 *                         preallocate = max(rhs)             # <<<<<<<<<<<<<< 
 *                     else:
 *                         preallocate = 0
 */
          __pyx_6 = PyTuple_New(1); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; goto __pyx_L9;}
          Py_INCREF(__pyx_v_rhs);
          PyTuple_SET_ITEM(__pyx_6, 0, __pyx_v_rhs);
          __pyx_3 = PyObject_CallObject(__pyx_builtin_max, __pyx_6); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; goto __pyx_L9;}
          Py_DECREF(__pyx_6); __pyx_6 = 0;
          __pyx_2 = PyInt_AsLong(__pyx_3); if (unlikely((__pyx_2 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; goto __pyx_L9;}
          Py_DECREF(__pyx_3); __pyx_3 = 0;
          __pyx_v_preallocate = __pyx_2;
          goto __pyx_L12;
        }
        /*else*/ {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":161
 *                         preallocate = max(rhs)
 *                     else:
 *                         preallocate = 0             # <<<<<<<<<<<<<< 
 *                 if self.sanity_checks:
 *                     if not (0 <= preallocate < maxelem):
 */
          __pyx_v_preallocate = 0;
        }
        __pyx_L12:;
        goto __pyx_L11;
      }
      __pyx_L11:;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":162
 *                     else:
 *                         preallocate = 0
 *                 if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                     if not (0 <= preallocate < maxelem):
 *                         raise OverflowError, "Can't integers bigger than %s" % maxelem
 */
      __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
      if (__pyx_1) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":163
 *                         preallocate = 0
 *                 if self.sanity_checks:
 *                     if not (0 <= preallocate < maxelem):             # <<<<<<<<<<<<<< 
 *                         raise OverflowError, "Can't integers bigger than %s" % maxelem
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 */
        __pyx_5 = (0 <= __pyx_v_preallocate);
        if (__pyx_5) {
          __pyx_5 = (__pyx_v_preallocate < maxelem);
        }
        __pyx_7 = (!__pyx_5);
        if (__pyx_7) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":164
 *                 if self.sanity_checks:
 *                     if not (0 <= preallocate < maxelem):
 *                         raise OverflowError, "Can't integers bigger than %s" % maxelem             # <<<<<<<<<<<<<< 
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 *                 if trailing_bits:
 */
          __pyx_4 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; goto __pyx_L9;}
          __pyx_6 = PyNumber_Remainder(__pyx_k19p, __pyx_4); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; goto __pyx_L9;}
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_6, 0);
          Py_DECREF(__pyx_6); __pyx_6 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; goto __pyx_L9;}
          goto __pyx_L14;
        }
        __pyx_L14:;
        goto __pyx_L13;
      }
      __pyx_L13:;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":165
 *                     if not (0 <= preallocate < maxelem):
 *                         raise OverflowError, "Can't integers bigger than %s" % maxelem
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)             # <<<<<<<<<<<<<< 
 *                 if trailing_bits:
 *                     last = 0
 */
      ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreate(__pyx_v_preallocate,__pyx_v_trailing_bits);

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":166
 *                         raise OverflowError, "Can't integers bigger than %s" % maxelem
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 *                 if trailing_bits:             # <<<<<<<<<<<<<< 
 *                     last = 0
 *                     if self.sanity_checks:
 */
      __pyx_2 = __pyx_v_trailing_bits;
      if (__pyx_2) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":167
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 *                 if trailing_bits:
 *                     last = 0             # <<<<<<<<<<<<<< 
 *                     if self.sanity_checks:
 *                         for elem in rhs:
 */
        __pyx_v_last = 0;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":168
 *                 if trailing_bits:
 *                     last = 0
 *                     if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                         for elem in rhs:
 *                             if elem < 0:
 */
        __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
        if (__pyx_1) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":169
 *                     last = 0
 *                     if self.sanity_checks:
 *                         for elem in rhs:             # <<<<<<<<<<<<<< 
 *                             if elem < 0:
 *                                 raise ValueError, "Negative numbers, not allowed"
 */
          if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_8 = 0; __pyx_3 = __pyx_v_rhs; Py_INCREF(__pyx_3); }
          else { __pyx_3 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; goto __pyx_L9;} }
          for (;;) {
            if (PyList_CheckExact(__pyx_3)) { if (__pyx_8 >= PyList_GET_SIZE(__pyx_3)) break; __pyx_4 = PyList_GET_ITEM(__pyx_3, __pyx_8++); Py_INCREF(__pyx_4); }
            else {
              __pyx_4 = PyIter_Next(__pyx_3);
              if (!__pyx_4) {
                break;
              }
            }
            __pyx_2 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_2 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; goto __pyx_L9;}
            Py_DECREF(__pyx_4); __pyx_4 = 0;
            __pyx_v_elem = __pyx_2;

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":170
 *                     if self.sanity_checks:
 *                         for elem in rhs:
 *                             if elem < 0:             # <<<<<<<<<<<<<< 
 *                                 raise ValueError, "Negative numbers, not allowed"
 *                             elif elem > maxelem:
 */
            __pyx_5 = (__pyx_v_elem < 0);
            if (__pyx_5) {

              /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":171
 *                         for elem in rhs:
 *                             if elem < 0:
 *                                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                             elif elem > maxelem:
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem
 */
              __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k20p, 0);
              {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; goto __pyx_L9;}
              goto __pyx_L19;
            }
            __pyx_7 = (__pyx_v_elem > maxelem);
            if (__pyx_7) {

              /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":173
 *                                 raise ValueError, "Negative numbers, not allowed"
 *                             elif elem > maxelem:
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *                             for remelem from last <= remelem < elem:
 *                                 intBitSetDelElem(self.bitset, remelem)
 */
              __pyx_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; goto __pyx_L9;}
              __pyx_4 = PyNumber_Remainder(__pyx_k21p, __pyx_6); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; goto __pyx_L9;}
              Py_DECREF(__pyx_6); __pyx_6 = 0;
              __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
              Py_DECREF(__pyx_4); __pyx_4 = 0;
              {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; goto __pyx_L9;}
              goto __pyx_L19;
            }
            __pyx_L19:;

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":174
 *                             elif elem > maxelem:
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem
 *                             for remelem from last <= remelem < elem:             # <<<<<<<<<<<<<< 
 *                                 intBitSetDelElem(self.bitset, remelem)
 *                             last = elem + 1
 */
            for (__pyx_v_remelem = __pyx_v_last; __pyx_v_remelem < __pyx_v_elem; __pyx_v_remelem++) {

              /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":175
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem
 *                             for remelem from last <= remelem < elem:
 *                                 intBitSetDelElem(self.bitset, remelem)             # <<<<<<<<<<<<<< 
 *                             last = elem + 1
 *                     else:
 */
              intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_remelem);
            }

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":176
 *                             for remelem from last <= remelem < elem:
 *                                 intBitSetDelElem(self.bitset, remelem)
 *                             last = elem + 1             # <<<<<<<<<<<<<< 
 *                     else:
 *                         for elem in rhs:
 */
            __pyx_v_last = (__pyx_v_elem + 1);
          }
          Py_DECREF(__pyx_3); __pyx_3 = 0;
          goto __pyx_L16;
        }
        /*else*/ {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":178
 *                             last = elem + 1
 *                     else:
 *                         for elem in rhs:             # <<<<<<<<<<<<<< 
 *                             for remelem from last <= remelem < elem:
 *                                 intBitSetDelElem(self.bitset, remelem)
 */
          if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_8 = 0; __pyx_6 = __pyx_v_rhs; Py_INCREF(__pyx_6); }
          else { __pyx_6 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; goto __pyx_L9;} }
          for (;;) {
            if (PyList_CheckExact(__pyx_6)) { if (__pyx_8 >= PyList_GET_SIZE(__pyx_6)) break; __pyx_4 = PyList_GET_ITEM(__pyx_6, __pyx_8++); Py_INCREF(__pyx_4); }
            else {
              __pyx_4 = PyIter_Next(__pyx_6);
              if (!__pyx_4) {
                break;
              }
            }
            __pyx_2 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_2 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; goto __pyx_L9;}
            Py_DECREF(__pyx_4); __pyx_4 = 0;
            __pyx_v_elem = __pyx_2;

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":179
 *                     else:
 *                         for elem in rhs:
 *                             for remelem from last <= remelem < elem:             # <<<<<<<<<<<<<< 
 *                                 intBitSetDelElem(self.bitset, remelem)
 *                             last = elem + 1
 */
            for (__pyx_v_remelem = __pyx_v_last; __pyx_v_remelem < __pyx_v_elem; __pyx_v_remelem++) {

              /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":180
 *                         for elem in rhs:
 *                             for remelem from last <= remelem < elem:
 *                                 intBitSetDelElem(self.bitset, remelem)             # <<<<<<<<<<<<<< 
 *                             last = elem + 1
 * 
 */
              intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_remelem);
            }

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":181
 *                             for remelem from last <= remelem < elem:
 *                                 intBitSetDelElem(self.bitset, remelem)
 *                             last = elem + 1             # <<<<<<<<<<<<<< 
 * 
 *                 else:
 */
            __pyx_v_last = (__pyx_v_elem + 1);
          }
          Py_DECREF(__pyx_6); __pyx_6 = 0;
        }
        __pyx_L16:;
        goto __pyx_L15;
      }
      /*else*/ {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":184
 * 
 *                 else:
 *                     if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                         for elem in rhs:
 *                             if elem < 0:
 */
        __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
        if (__pyx_1) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":185
 *                 else:
 *                     if self.sanity_checks:
 *                         for elem in rhs:             # <<<<<<<<<<<<<< 
 *                             if elem < 0:
 *                                 raise ValueError, "Negative numbers, not allowed"
 */
          if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_8 = 0; __pyx_3 = __pyx_v_rhs; Py_INCREF(__pyx_3); }
          else { __pyx_3 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; goto __pyx_L9;} }
          for (;;) {
            if (PyList_CheckExact(__pyx_3)) { if (__pyx_8 >= PyList_GET_SIZE(__pyx_3)) break; __pyx_4 = PyList_GET_ITEM(__pyx_3, __pyx_8++); Py_INCREF(__pyx_4); }
            else {
              __pyx_4 = PyIter_Next(__pyx_3);
              if (!__pyx_4) {
                break;
              }
            }
            __pyx_2 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_2 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; goto __pyx_L9;}
            Py_DECREF(__pyx_4); __pyx_4 = 0;
            __pyx_v_elem = __pyx_2;

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":186
 *                     if self.sanity_checks:
 *                         for elem in rhs:
 *                             if elem < 0:             # <<<<<<<<<<<<<< 
 *                                 raise ValueError, "Negative numbers, not allowed"
 *                             elif elem > maxelem:
 */
            __pyx_5 = (__pyx_v_elem < 0);
            if (__pyx_5) {

              /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":187
 *                         for elem in rhs:
 *                             if elem < 0:
 *                                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                             elif elem > maxelem:
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem
 */
              __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k22p, 0);
              {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; goto __pyx_L9;}
              goto __pyx_L29;
            }
            __pyx_7 = (__pyx_v_elem > maxelem);
            if (__pyx_7) {

              /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":189
 *                                 raise ValueError, "Negative numbers, not allowed"
 *                             elif elem > maxelem:
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *                             intBitSetAddElem(self.bitset, elem)
 *                     else:
 */
              __pyx_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; goto __pyx_L9;}
              __pyx_4 = PyNumber_Remainder(__pyx_k23p, __pyx_6); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; goto __pyx_L9;}
              Py_DECREF(__pyx_6); __pyx_6 = 0;
              __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
              Py_DECREF(__pyx_4); __pyx_4 = 0;
              {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; goto __pyx_L9;}
              goto __pyx_L29;
            }
            __pyx_L29:;

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":190
 *                             elif elem > maxelem:
 *                                 raise OverflowError, "Elements must be <= %s" % maxelem
 *                             intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *                     else:
 *                         for elem in rhs:
 */
            intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
          }
          Py_DECREF(__pyx_3); __pyx_3 = 0;
          goto __pyx_L26;
        }
        /*else*/ {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":192
 *                             intBitSetAddElem(self.bitset, elem)
 *                     else:
 *                         for elem in rhs:             # <<<<<<<<<<<<<< 
 *                             intBitSetAddElem(self.bitset, elem)
 *             except Exception, msg:
 */
          if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_8 = 0; __pyx_6 = __pyx_v_rhs; Py_INCREF(__pyx_6); }
          else { __pyx_6 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; goto __pyx_L9;} }
          for (;;) {
            if (PyList_CheckExact(__pyx_6)) { if (__pyx_8 >= PyList_GET_SIZE(__pyx_6)) break; __pyx_4 = PyList_GET_ITEM(__pyx_6, __pyx_8++); Py_INCREF(__pyx_4); }
            else {
              __pyx_4 = PyIter_Next(__pyx_6);
              if (!__pyx_4) {
                break;
              }
            }
            __pyx_2 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_2 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; goto __pyx_L9;}
            Py_DECREF(__pyx_4); __pyx_4 = 0;
            __pyx_v_elem = __pyx_2;

            /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":193
 *                     else:
 *                         for elem in rhs:
 *                             intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *             except Exception, msg:
 *                 raise ValueError, "retrieving integers from rhs is impossible: %s" % msg
 */
            intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
          }
          Py_DECREF(__pyx_6); __pyx_6 = 0;
        }
        __pyx_L26:;
      }
      __pyx_L15:;
    }
    goto __pyx_L10;
    __pyx_L9:;
    Py_XDECREF(__pyx_3); __pyx_3 = 0;
    Py_XDECREF(__pyx_4); __pyx_4 = 0;
    Py_XDECREF(__pyx_6); __pyx_6 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":194
 *                         for elem in rhs:
 *                             intBitSetAddElem(self.bitset, elem)
 *             except Exception, msg:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "retrieving integers from rhs is impossible: %s" % msg
 *         else:
 */
    __pyx_2 = PyErr_ExceptionMatches(__pyx_builtin_Exception);
    if (__pyx_2) {
      __Pyx_AddTraceback("intbitset.__new__");
      __pyx_3 = __Pyx_GetExcValue(); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; goto __pyx_L1;}
      Py_DECREF(__pyx_v_msg);
      __pyx_v_msg = __pyx_3;
      __pyx_3 = 0;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":195
 *                             intBitSetAddElem(self.bitset, elem)
 *             except Exception, msg:
 *                 raise ValueError, "retrieving integers from rhs is impossible: %s" % msg             # <<<<<<<<<<<<<< 
 *         else:
 *             raise TypeError, "rhs is of unknown type %s" % type(rhs)
 */
      __pyx_4 = PyNumber_Remainder(__pyx_k24p, __pyx_v_msg); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; goto __pyx_L1;}
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; goto __pyx_L1;}
      goto __pyx_L10;
    }
    goto __pyx_L1;
    __pyx_L10:;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":197
 *                 raise ValueError, "retrieving integers from rhs is impossible: %s" % msg
 *         else:
 *             raise TypeError, "rhs is of unknown type %s" % type(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def __dealloc__(self):
 */
    __pyx_6 = PyTuple_New(1); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; goto __pyx_L1;}
    Py_INCREF(__pyx_v_rhs);
    PyTuple_SET_ITEM(__pyx_6, 0, __pyx_v_rhs);
    __pyx_3 = PyObject_CallObject(((PyObject*)&PyType_Type), __pyx_6); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; goto __pyx_L1;}
    Py_DECREF(__pyx_6); __pyx_6 = 0;
    __pyx_4 = PyNumber_Remainder(__pyx_k25p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_builtin_TypeError, __pyx_4, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; goto __pyx_L1;}
  }
  __pyx_L3:;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_6);
  __Pyx_AddTraceback("intbitset.intbitset.__new__");
  __pyx_r = -1;
  __pyx_L0:;
  Py_DECREF(__pyx_v_msg);
  Py_DECREF(__pyx_v_tmp);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  Py_DECREF(__pyx_v_sanity_checks);
  return __pyx_r;
}

static void __pyx_f_py_9intbitset_9intbitset___dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_f_py_9intbitset_9intbitset___dealloc__(PyObject *__pyx_v_self) {
  int __pyx_1;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":200
 * 
 *     def __dealloc__(self):
 *         if self.bitset:             # <<<<<<<<<<<<<< 
 *             intBitSetDestroy(self.bitset)
 * 
 */
  __pyx_1 = (((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset != 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":201
 *     def __dealloc__(self):
 *         if self.bitset:
 *             intBitSetDestroy(self.bitset)             # <<<<<<<<<<<<<< 
 * 
 *     def __contains__(self, int elem):
 */
    intBitSetDestroy(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);
    goto __pyx_L2;
  }
  __pyx_L2:;

  Py_DECREF(__pyx_v_self);
}

static PyObject *__pyx_k26p;
static PyObject *__pyx_k27p;

static char (__pyx_k26[]) = "Negative numbers, not allowed";
static char (__pyx_k27[]) = "Element must be <= %s";

static int __pyx_f_py_9intbitset_9intbitset___contains__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static int __pyx_f_py_9intbitset_9intbitset___contains__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  int __pyx_r;
  bool_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  assert(__pyx_arg_elem); {
    __pyx_v_elem = PyInt_AsLong(__pyx_arg_elem); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; goto __pyx_L1;}
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":204
 * 
 *     def __contains__(self, int elem):
 *         if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":205
 *     def __contains__(self, int elem):
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 */
    __pyx_2 = (__pyx_v_elem < 0);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":206
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 */
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k26p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_2 = (__pyx_v_elem > maxelem);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":208
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         return intBitSetIsInElem(self.bitset, elem) != 0
 * 
 */
      __pyx_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k27p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_L3:;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":209
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 *         return intBitSetIsInElem(self.bitset, elem) != 0             # <<<<<<<<<<<<<< 
 * 
 *     def __cmp__(self, intbitset rhs not None):
 */
  __pyx_r = (intBitSetIsInElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem) != 0);
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.__contains__");
  __pyx_r = -1;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k28p;

static char (__pyx_k28[]) = "cannot compare intbitset using cmp()";

static int __pyx_f_py_9intbitset_9intbitset___cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static int __pyx_f_py_9intbitset_9intbitset___cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_r;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":212
 * 
 *     def __cmp__(self, intbitset rhs not None):
 *         raise TypeError, "cannot compare intbitset using cmp()"             # <<<<<<<<<<<<<< 
 * 
 *     def __richcmp__(self, intbitset rhs not None, int op):
 */
  __Pyx_Raise(__pyx_builtin_TypeError, __pyx_k28p, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; goto __pyx_L1;}

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("intbitset.intbitset.__cmp__");
  __pyx_r = -1;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_num_2;

static PyObject *__pyx_f_py_9intbitset_9intbitset___richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs, int __pyx_v_op); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs, int __pyx_v_op) {
  unsigned short __pyx_v_tmp;
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":216
 *     def __richcmp__(self, intbitset rhs not None, int op):
 *         cdef short unsigned int tmp
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         if op == 0: # <
 *             return tmp == 1
 */
  __pyx_v_tmp = intBitSetCmp(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":217
 *         cdef short unsigned int tmp
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)
 *         if op == 0: # <             # <<<<<<<<<<<<<< 
 *             return tmp == 1
 *         if op == 1: # <=
 */
  __pyx_1 = (__pyx_v_op == 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":218
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)
 *         if op == 0: # <
 *             return tmp == 1             # <<<<<<<<<<<<<< 
 *         if op == 1: # <=
 *             return tmp <= 1
 */
    __pyx_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp == 1)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; goto __pyx_L1;}
    __pyx_r = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":219
 *         if op == 0: # <
 *             return tmp == 1
 *         if op == 1: # <=             # <<<<<<<<<<<<<< 
 *             return tmp <= 1
 *         if op == 2: # ==
 */
  __pyx_1 = (__pyx_v_op == 1);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":220
 *             return tmp == 1
 *         if op == 1: # <=
 *             return tmp <= 1             # <<<<<<<<<<<<<< 
 *         if op == 2: # ==
 *             return tmp == 0
 */
    __pyx_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp <= 1)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; goto __pyx_L1;}
    __pyx_r = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":221
 *         if op == 1: # <=
 *             return tmp <= 1
 *         if op == 2: # ==             # <<<<<<<<<<<<<< 
 *             return tmp == 0
 *         if op == 3: # !=
 */
  __pyx_1 = (__pyx_v_op == 2);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":222
 *             return tmp <= 1
 *         if op == 2: # ==
 *             return tmp == 0             # <<<<<<<<<<<<<< 
 *         if op == 3: # !=
 *             return tmp > 0
 */
    __pyx_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp == 0)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 222; goto __pyx_L1;}
    __pyx_r = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":223
 *         if op == 2: # ==
 *             return tmp == 0
 *         if op == 3: # !=             # <<<<<<<<<<<<<< 
 *             return tmp > 0
 *         if op == 4: # >
 */
  __pyx_1 = (__pyx_v_op == 3);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":224
 *             return tmp == 0
 *         if op == 3: # !=
 *             return tmp > 0             # <<<<<<<<<<<<<< 
 *         if op == 4: # >
 *             return tmp == 2
 */
    __pyx_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp > 0)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 224; goto __pyx_L1;}
    __pyx_r = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":225
 *         if op == 3: # !=
 *             return tmp > 0
 *         if op == 4: # >             # <<<<<<<<<<<<<< 
 *             return tmp == 2
 *         if op == 5: # >=
 */
  __pyx_1 = (__pyx_v_op == 4);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":226
 *             return tmp > 0
 *         if op == 4: # >
 *             return tmp == 2             # <<<<<<<<<<<<<< 
 *         if op == 5: # >=
 *             return tmp in (0, 2)
 */
    __pyx_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp == 2)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; goto __pyx_L1;}
    __pyx_r = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":227
 *         if op == 4: # >
 *             return tmp == 2
 *         if op == 5: # >=             # <<<<<<<<<<<<<< 
 *             return tmp in (0, 2)
 * 
 */
  __pyx_1 = (__pyx_v_op == 5);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":228
 *             return tmp == 2
 *         if op == 5: # >=
 *             return tmp in (0, 2)             # <<<<<<<<<<<<<< 
 * 
 *     def __len__(self):
 */
    __pyx_2 = PyInt_FromLong(__pyx_v_tmp); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; goto __pyx_L1;}
    __pyx_3 = PyTuple_New(2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; goto __pyx_L1;}
    Py_INCREF(__pyx_num_0);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_num_0);
    Py_INCREF(__pyx_num_2);
    PyTuple_SET_ITEM(__pyx_3, 1, __pyx_num_2);
    __pyx_1 = (PySequence_Contains(__pyx_3, __pyx_2)); if (unlikely(__pyx_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __pyx_2 = __Pyx_PyBool_FromLong(__pyx_1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; goto __pyx_L1;}
    __pyx_r = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L0;
    goto __pyx_L7;
  }
  __pyx_L7:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.__richcmp__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static Py_ssize_t __pyx_f_py_9intbitset_9intbitset___len__(PyObject *__pyx_v_self); /*proto*/
static Py_ssize_t __pyx_f_py_9intbitset_9intbitset___len__(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":231
 * 
 *     def __len__(self):
 *         return intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<< 
 * 
 *     def __hash__(self):
 */
  __pyx_r = intBitSetGetTot(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static long __pyx_f_py_9intbitset_9intbitset___hash__(PyObject *__pyx_v_self); /*proto*/
static long __pyx_f_py_9intbitset_9intbitset___hash__(PyObject *__pyx_v_self) {
  long __pyx_r;
  PyObject *__pyx_1 = 0;
  long __pyx_2;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":234
 * 
 *     def __hash__(self):
 *         return hash(PyString_FromStringAndSize(<char *>self.bitset.bitset, wordbytesize * (intBitSetGetTot(self.bitset) / wordbitsize + 1)))             # <<<<<<<<<<<<<< 
 * 
 *     def __nonzero__(self):
 */
  __pyx_1 = PyString_FromStringAndSize(((char (*))((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->bitset),(wordbytesize * ((intBitSetGetTot(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset) / wordbitsize) + 1))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; goto __pyx_L1;}
  __pyx_2 = PyObject_Hash(__pyx_1); if (unlikely(__pyx_2 == -1 && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_2;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("intbitset.intbitset.__hash__");
  __pyx_r = -1;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static int __pyx_f_py_9intbitset_9intbitset___nonzero__(PyObject *__pyx_v_self); /*proto*/
static int __pyx_f_py_9intbitset_9intbitset___nonzero__(PyObject *__pyx_v_self) {
  int __pyx_r;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":237
 * 
 *     def __nonzero__(self):
 *         return not intBitSetEmpty(self.bitset)             # <<<<<<<<<<<<<< 
 * 
 *     def __iadd__(self, rhs):
 */
  __pyx_r = (!intBitSetEmpty(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset));
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k29p;
static PyObject *__pyx_k30p;
static PyObject *__pyx_k31p;
static PyObject *__pyx_k32p;
static PyObject *__pyx_k33p;
static PyObject *__pyx_k34p;

static char (__pyx_k29[]) = "Negative numbers, not allowed";
static char (__pyx_k30[]) = "rhs must be <= %s";
static char (__pyx_k31[]) = "Negative numbers, not allowed";
static char (__pyx_k32[]) = "Elements must be <= %s";
static char (__pyx_k33[]) = "Negative numbers, not allowed";
static char (__pyx_k34[]) = "Elements must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset___iadd__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___iadd__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_v_elem;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;
  bool_t __pyx_3;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  Py_ssize_t __pyx_6;
  PyObject *__pyx_7 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":241
 *     def __iadd__(self, rhs):
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):             # <<<<<<<<<<<<<< 
 *             if self.sanity_checks:
 *                 if rhs < 0:
 */
  __pyx_1 = PyTuple_New(2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; goto __pyx_L1;}
  Py_INCREF(((PyObject*)&PyInt_Type));
  PyTuple_SET_ITEM(__pyx_1, 0, ((PyObject*)&PyInt_Type));
  Py_INCREF(((PyObject*)&PyLong_Type));
  PyTuple_SET_ITEM(__pyx_1, 1, ((PyObject*)&PyLong_Type));
  __pyx_2 = PyObject_IsInstance(__pyx_v_rhs,__pyx_1); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  if (__pyx_2) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":242
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                 if rhs < 0:
 *                     raise ValueError, "Negative numbers, not allowed"
 */
    __pyx_3 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_3) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":243
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:
 *                 if rhs < 0:             # <<<<<<<<<<<<<< 
 *                     raise ValueError, "Negative numbers, not allowed"
 *                 elif rhs > maxelem:
 */
      __pyx_1 = PyObject_RichCompare(__pyx_v_rhs, __pyx_num_0, Py_LT); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; goto __pyx_L1;}
      __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      if (__pyx_2) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":244
 *             if self.sanity_checks:
 *                 if rhs < 0:
 *                     raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                 elif rhs > maxelem:
 *                     raise OverflowError, "rhs must be <= %s" % maxelem
 */
        __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k29p, 0);
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; goto __pyx_L1;}
        goto __pyx_L4;
      }
      __pyx_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; goto __pyx_L1;}
      __pyx_4 = PyObject_RichCompare(__pyx_v_rhs, __pyx_1, Py_GT); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_4); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; goto __pyx_L1;}
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      if (__pyx_2) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":246
 *                     raise ValueError, "Negative numbers, not allowed"
 *                 elif rhs > maxelem:
 *                     raise OverflowError, "rhs must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *             intBitSetAddElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 */
        __pyx_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; goto __pyx_L1;}
        __pyx_4 = PyNumber_Remainder(__pyx_k30p, __pyx_1); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; goto __pyx_L1;}
        Py_DECREF(__pyx_1); __pyx_1 = 0;
        __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
        Py_DECREF(__pyx_4); __pyx_4 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; goto __pyx_L1;}
        goto __pyx_L4;
      }
      __pyx_L4:;
      goto __pyx_L3;
    }
    __pyx_L3:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":247
 *                 elif rhs > maxelem:
 *                     raise OverflowError, "rhs must be <= %s" % maxelem
 *             intBitSetAddElem(self.bitset, rhs)             # <<<<<<<<<<<<<< 
 *         elif isinstance(rhs, intbitset):
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)
 */
    __pyx_5 = PyInt_AsLong(__pyx_v_rhs); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 247; goto __pyx_L1;}
    intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_5);
    goto __pyx_L2;
  }
  __pyx_2 = PyObject_IsInstance(__pyx_v_rhs,((PyObject*)__pyx_ptype_9intbitset_intbitset)); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 248; goto __pyx_L1;}
  if (__pyx_2) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":249
 *             intBitSetAddElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)             # <<<<<<<<<<<<<< 
 *         else:
 *             if self.sanity_checks:
 */
    intBitSetIUnion(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);
    goto __pyx_L2;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":251
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)
 *         else:
 *             if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                 for elem in rhs:
 *                     if elem < 0:
 */
    __pyx_3 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_3) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":252
 *         else:
 *             if self.sanity_checks:
 *                 for elem in rhs:             # <<<<<<<<<<<<<< 
 *                     if elem < 0:
 *                         raise ValueError, "Negative numbers, not allowed"
 */
      if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_6 = 0; __pyx_1 = __pyx_v_rhs; Py_INCREF(__pyx_1); }
      else { __pyx_1 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; goto __pyx_L1;} }
      for (;;) {
        if (PyList_CheckExact(__pyx_1)) { if (__pyx_6 >= PyList_GET_SIZE(__pyx_1)) break; __pyx_4 = PyList_GET_ITEM(__pyx_1, __pyx_6++); Py_INCREF(__pyx_4); }
        else {
          __pyx_4 = PyIter_Next(__pyx_1);
          if (!__pyx_4) {
            break;
          }
        }
        __pyx_5 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; goto __pyx_L1;}
        Py_DECREF(__pyx_4); __pyx_4 = 0;
        __pyx_v_elem = __pyx_5;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":253
 *             if self.sanity_checks:
 *                 for elem in rhs:
 *                     if elem < 0:             # <<<<<<<<<<<<<< 
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif elem > maxelem:
 */
        __pyx_2 = (__pyx_v_elem < 0);
        if (__pyx_2) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":254
 *                 for elem in rhs:
 *                     if elem < 0:
 *                         raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 */
          __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k31p, 0);
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; goto __pyx_L1;}
          goto __pyx_L8;
        }
        __pyx_2 = (__pyx_v_elem > maxelem);
        if (__pyx_2) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":256
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *                     intBitSetAddElem(self.bitset, elem)
 *             else:
 */
          __pyx_4 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; goto __pyx_L1;}
          __pyx_7 = PyNumber_Remainder(__pyx_k32p, __pyx_4); if (unlikely(!__pyx_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; goto __pyx_L1;}
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_7, 0);
          Py_DECREF(__pyx_7); __pyx_7 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; goto __pyx_L1;}
          goto __pyx_L8;
        }
        __pyx_L8:;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":257
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 *                     intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *             else:
 *                 for elem in rhs:
 */
        intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
      }
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      goto __pyx_L5;
    }
    /*else*/ {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":259
 *                     intBitSetAddElem(self.bitset, elem)
 *             else:
 *                 for elem in rhs:             # <<<<<<<<<<<<<< 
 *                     if elem < 0:
 *                         raise ValueError, "Negative numbers, not allowed"
 */
      if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_6 = 0; __pyx_4 = __pyx_v_rhs; Py_INCREF(__pyx_4); }
      else { __pyx_4 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; goto __pyx_L1;} }
      for (;;) {
        if (PyList_CheckExact(__pyx_4)) { if (__pyx_6 >= PyList_GET_SIZE(__pyx_4)) break; __pyx_7 = PyList_GET_ITEM(__pyx_4, __pyx_6++); Py_INCREF(__pyx_7); }
        else {
          __pyx_7 = PyIter_Next(__pyx_4);
          if (!__pyx_7) {
            break;
          }
        }
        __pyx_5 = PyInt_AsLong(__pyx_7); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; goto __pyx_L1;}
        Py_DECREF(__pyx_7); __pyx_7 = 0;
        __pyx_v_elem = __pyx_5;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":260
 *             else:
 *                 for elem in rhs:
 *                     if elem < 0:             # <<<<<<<<<<<<<< 
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif elem > maxelem:
 */
        __pyx_2 = (__pyx_v_elem < 0);
        if (__pyx_2) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":261
 *                 for elem in rhs:
 *                     if elem < 0:
 *                         raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 */
          __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k33p, 0);
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; goto __pyx_L1;}
          goto __pyx_L11;
        }
        __pyx_2 = (__pyx_v_elem > maxelem);
        if (__pyx_2) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":263
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *                     intBitSetAddElem(self.bitset, elem)
 *         return self
 */
          __pyx_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; goto __pyx_L1;}
          __pyx_7 = PyNumber_Remainder(__pyx_k34p, __pyx_1); if (unlikely(!__pyx_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; goto __pyx_L1;}
          Py_DECREF(__pyx_1); __pyx_1 = 0;
          __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_7, 0);
          Py_DECREF(__pyx_7); __pyx_7 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; goto __pyx_L1;}
          goto __pyx_L11;
        }
        __pyx_L11:;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":264
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 *                     intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *         return self
 * 
 */
        intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
      }
      Py_DECREF(__pyx_4); __pyx_4 = 0;
    }
    __pyx_L5:;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":265
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 *                     intBitSetAddElem(self.bitset, elem)
 *         return self             # <<<<<<<<<<<<<< 
 * 
 *     def __isub__(self, rhs):
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_7);
  __Pyx_AddTraceback("intbitset.intbitset.__iadd__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_k35p;
static PyObject *__pyx_k36p;
static PyObject *__pyx_k37p;
static PyObject *__pyx_k38p;

static char (__pyx_k35[]) = "Negative numbers, not allowed";
static char (__pyx_k36[]) = "rhs must be <= %s";
static char (__pyx_k37[]) = "Negative numbers, not allowed";
static char (__pyx_k38[]) = "Elements must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset___isub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___isub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_v_elem;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;
  bool_t __pyx_3;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  Py_ssize_t __pyx_6;
  PyObject *__pyx_7 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":269
 *     def __isub__(self, rhs):
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):             # <<<<<<<<<<<<<< 
 *             if self.sanity_checks:
 *                 if rhs < 0:
 */
  __pyx_1 = PyTuple_New(2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; goto __pyx_L1;}
  Py_INCREF(((PyObject*)&PyInt_Type));
  PyTuple_SET_ITEM(__pyx_1, 0, ((PyObject*)&PyInt_Type));
  Py_INCREF(((PyObject*)&PyLong_Type));
  PyTuple_SET_ITEM(__pyx_1, 1, ((PyObject*)&PyLong_Type));
  __pyx_2 = PyObject_IsInstance(__pyx_v_rhs,__pyx_1); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  if (__pyx_2) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":270
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                 if rhs < 0:
 *                     raise ValueError, "Negative numbers, not allowed"
 */
    __pyx_3 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_3) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":271
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:
 *                 if rhs < 0:             # <<<<<<<<<<<<<< 
 *                     raise ValueError, "Negative numbers, not allowed"
 *                 elif rhs > maxelem:
 */
      __pyx_1 = PyObject_RichCompare(__pyx_v_rhs, __pyx_num_0, Py_LT); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; goto __pyx_L1;}
      __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      if (__pyx_2) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":272
 *             if self.sanity_checks:
 *                 if rhs < 0:
 *                     raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                 elif rhs > maxelem:
 *                     raise OverflowError, "rhs must be <= %s" % maxelem
 */
        __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k35p, 0);
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; goto __pyx_L1;}
        goto __pyx_L4;
      }
      __pyx_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 273; goto __pyx_L1;}
      __pyx_4 = PyObject_RichCompare(__pyx_v_rhs, __pyx_1, Py_GT); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 273; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_4); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 273; goto __pyx_L1;}
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      if (__pyx_2) {

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":274
 *                     raise ValueError, "Negative numbers, not allowed"
 *                 elif rhs > maxelem:
 *                     raise OverflowError, "rhs must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *             intBitSetDelElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 */
        __pyx_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; goto __pyx_L1;}
        __pyx_4 = PyNumber_Remainder(__pyx_k36p, __pyx_1); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; goto __pyx_L1;}
        Py_DECREF(__pyx_1); __pyx_1 = 0;
        __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
        Py_DECREF(__pyx_4); __pyx_4 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; goto __pyx_L1;}
        goto __pyx_L4;
      }
      __pyx_L4:;
      goto __pyx_L3;
    }
    __pyx_L3:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":275
 *                 elif rhs > maxelem:
 *                     raise OverflowError, "rhs must be <= %s" % maxelem
 *             intBitSetDelElem(self.bitset, rhs)             # <<<<<<<<<<<<<< 
 *         elif isinstance(rhs, intbitset):
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)
 */
    __pyx_5 = PyInt_AsLong(__pyx_v_rhs); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; goto __pyx_L1;}
    intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_5);
    goto __pyx_L2;
  }
  __pyx_2 = PyObject_IsInstance(__pyx_v_rhs,((PyObject*)__pyx_ptype_9intbitset_intbitset)); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 276; goto __pyx_L1;}
  if (__pyx_2) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":277
 *             intBitSetDelElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)             # <<<<<<<<<<<<<< 
 *         else:
 *             if self.sanity_checks:
 */
    intBitSetISub(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);
    goto __pyx_L2;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":279
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)
 *         else:
 *             if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                 for elem in rhs:
 *                     if elem < 0:
 */
    __pyx_3 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_3) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":280
 *         else:
 *             if self.sanity_checks:
 *                 for elem in rhs:             # <<<<<<<<<<<<<< 
 *                     if elem < 0:
 *                         raise ValueError, "Negative numbers, not allowed"
 */
      if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_6 = 0; __pyx_1 = __pyx_v_rhs; Py_INCREF(__pyx_1); }
      else { __pyx_1 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; goto __pyx_L1;} }
      for (;;) {
        if (PyList_CheckExact(__pyx_1)) { if (__pyx_6 >= PyList_GET_SIZE(__pyx_1)) break; __pyx_4 = PyList_GET_ITEM(__pyx_1, __pyx_6++); Py_INCREF(__pyx_4); }
        else {
          __pyx_4 = PyIter_Next(__pyx_1);
          if (!__pyx_4) {
            break;
          }
        }
        __pyx_5 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; goto __pyx_L1;}
        Py_DECREF(__pyx_4); __pyx_4 = 0;
        __pyx_v_elem = __pyx_5;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":281
 *             if self.sanity_checks:
 *                 for elem in rhs:
 *                     if elem < 0:             # <<<<<<<<<<<<<< 
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif elem > maxelem:
 */
        __pyx_2 = (__pyx_v_elem < 0);
        if (__pyx_2) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":282
 *                 for elem in rhs:
 *                     if elem < 0:
 *                         raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 */
          __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k37p, 0);
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 282; goto __pyx_L1;}
          goto __pyx_L8;
        }
        __pyx_2 = (__pyx_v_elem > maxelem);
        if (__pyx_2) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":284
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *                     intBitSetDelElem(self.bitset, elem)
 *             else:
 */
          __pyx_4 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; goto __pyx_L1;}
          __pyx_7 = PyNumber_Remainder(__pyx_k38p, __pyx_4); if (unlikely(!__pyx_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; goto __pyx_L1;}
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_7, 0);
          Py_DECREF(__pyx_7); __pyx_7 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; goto __pyx_L1;}
          goto __pyx_L8;
        }
        __pyx_L8:;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":285
 *                     elif elem > maxelem:
 *                         raise OverflowError, "Elements must be <= %s" % maxelem
 *                     intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *             else:
 *                 for elem in rhs:
 */
        intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
      }
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      goto __pyx_L5;
    }
    /*else*/ {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":287
 *                     intBitSetDelElem(self.bitset, elem)
 *             else:
 *                 for elem in rhs:             # <<<<<<<<<<<<<< 
 *                     intBitSetDelElem(self.bitset, elem)
 *         return self
 */
      if (PyList_CheckExact(__pyx_v_rhs)) { __pyx_6 = 0; __pyx_4 = __pyx_v_rhs; Py_INCREF(__pyx_4); }
      else { __pyx_4 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; goto __pyx_L1;} }
      for (;;) {
        if (PyList_CheckExact(__pyx_4)) { if (__pyx_6 >= PyList_GET_SIZE(__pyx_4)) break; __pyx_7 = PyList_GET_ITEM(__pyx_4, __pyx_6++); Py_INCREF(__pyx_7); }
        else {
          __pyx_7 = PyIter_Next(__pyx_4);
          if (!__pyx_7) {
            break;
          }
        }
        __pyx_5 = PyInt_AsLong(__pyx_7); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; goto __pyx_L1;}
        Py_DECREF(__pyx_7); __pyx_7 = 0;
        __pyx_v_elem = __pyx_5;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":288
 *             else:
 *                 for elem in rhs:
 *                     intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *         return self
 * 
 */
        intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
      }
      Py_DECREF(__pyx_4); __pyx_4 = 0;
    }
    __pyx_L5:;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":289
 *                 for elem in rhs:
 *                     intBitSetDelElem(self.bitset, elem)
 *         return self             # <<<<<<<<<<<<<< 
 * 
 *     def __deepcopy__(self, memo):
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_7);
  __Pyx_AddTraceback("intbitset.intbitset.__isub__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset___deepcopy__(PyObject *__pyx_v_self, PyObject *__pyx_v_memo); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___deepcopy__(PyObject *__pyx_v_self, PyObject *__pyx_v_memo) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_memo);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":292
 * 
 *     def __deepcopy__(self, memo):
 *         return intbitset(self)             # <<<<<<<<<<<<<< 
 * 
 *     def __del__(self, int elem):
 */
  __pyx_1 = PyTuple_New(1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 292; goto __pyx_L1;}
  Py_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_1, 0, __pyx_v_self);
  __pyx_2 = PyObject_CallObject(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 292; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_2;
  __pyx_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("intbitset.intbitset.__deepcopy__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_memo);
  return __pyx_r;
}

static PyObject *__pyx_k39p;
static PyObject *__pyx_k40p;

static char (__pyx_k39[]) = "Negative numbers, not allowed";
static char (__pyx_k40[]) = "Element must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset___del__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___del__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r;
  bool_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  assert(__pyx_arg_elem); {
    __pyx_v_elem = PyInt_AsLong(__pyx_arg_elem); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; goto __pyx_L1;}
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":295
 * 
 *     def __del__(self, int elem):
 *         if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":296
 *     def __del__(self, int elem):
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 */
    __pyx_2 = (__pyx_v_elem < 0);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":297
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 */
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k39p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_2 = (__pyx_v_elem > maxelem);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":299
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         intBitSetDelElem(self.bitset, elem)
 * 
 */
      __pyx_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k40p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_L3:;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":300
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 *         intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 * 
 *     def __and__(self, intbitset rhs not None):
 */
  intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.__del__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_num_1;

static PyObject *__pyx_n_no_allocate;


static PyObject *__pyx_f_py_9intbitset_9intbitset___and__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___and__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 302; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":303
 * 
 *     def __and__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<< 
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyTuple_New(0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; goto __pyx_L1;}
  __pyx_2 = PyDict_New(); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; goto __pyx_L1;}
  if (PyDict_SetItem(__pyx_2, __pyx_n_no_allocate, __pyx_num_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; goto __pyx_L1;}
  __pyx_3 = PyEval_CallObjectWithKeywords(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_3;
  __pyx_3 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":304
 *     def __and__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
  ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetIntersection(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":305
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def __or__(self, intbitset rhs not None):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.__and__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}


static PyObject *__pyx_f_py_9intbitset_9intbitset___or__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___or__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":308
 * 
 *     def __or__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<< 
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyTuple_New(0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; goto __pyx_L1;}
  __pyx_2 = PyDict_New(); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; goto __pyx_L1;}
  if (PyDict_SetItem(__pyx_2, __pyx_n_no_allocate, __pyx_num_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; goto __pyx_L1;}
  __pyx_3 = PyEval_CallObjectWithKeywords(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_3;
  __pyx_3 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":309
 *     def __or__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
  ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetUnion(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":310
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def __xor__(self, intbitset rhs not None):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.__or__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}


static PyObject *__pyx_f_py_9intbitset_9intbitset___xor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___xor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":313
 * 
 *     def __xor__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<< 
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyTuple_New(0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; goto __pyx_L1;}
  __pyx_2 = PyDict_New(); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; goto __pyx_L1;}
  if (PyDict_SetItem(__pyx_2, __pyx_n_no_allocate, __pyx_num_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; goto __pyx_L1;}
  __pyx_3 = PyEval_CallObjectWithKeywords(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_3;
  __pyx_3 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":314
 *     def __xor__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
  ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetXor(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":315
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def __sub__(self, intbitset rhs not None):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.__xor__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}


static PyObject *__pyx_f_py_9intbitset_9intbitset___sub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___sub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 317; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":318
 * 
 *     def __sub__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<< 
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyTuple_New(0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; goto __pyx_L1;}
  __pyx_2 = PyDict_New(); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; goto __pyx_L1;}
  if (PyDict_SetItem(__pyx_2, __pyx_n_no_allocate, __pyx_num_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; goto __pyx_L1;}
  __pyx_3 = PyEval_CallObjectWithKeywords(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_3;
  __pyx_3 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":319
 *     def __sub__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
  ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetSub(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":320
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def __iand__(self, intbitset rhs not None):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.__sub__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset___iand__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___iand__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 322; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":323
 * 
 *     def __iand__(self, intbitset rhs not None):
 *         intBitSetIIntersection(self.bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return self
 * 
 */
  intBitSetIIntersection(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":324
 *     def __iand__(self, intbitset rhs not None):
 *         intBitSetIIntersection(self.bitset, rhs.bitset)
 *         return self             # <<<<<<<<<<<<<< 
 * 
 *     def __ior__(self, intbitset rhs not None):
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("intbitset.intbitset.__iand__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset___ior__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___ior__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":327
 * 
 *     def __ior__(self, intbitset rhs not None):
 *         intBitSetIUnion(self.bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return self
 * 
 */
  intBitSetIUnion(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":328
 *     def __ior__(self, intbitset rhs not None):
 *         intBitSetIUnion(self.bitset, rhs.bitset)
 *         return self             # <<<<<<<<<<<<<< 
 * 
 *     def __ixor__(self, intbitset rhs not None):
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("intbitset.intbitset.__ior__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset___ixor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___ixor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_9intbitset_intbitset, 0, "rhs"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":331
 * 
 *     def __ixor__(self, intbitset rhs not None):
 *         intBitSetIXor(self.bitset, rhs.bitset)             # <<<<<<<<<<<<<< 
 *         return self
 * 
 */
  intBitSetIXor(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":332
 *     def __ixor__(self, intbitset rhs not None):
 *         intBitSetIXor(self.bitset, rhs.bitset)
 *         return self             # <<<<<<<<<<<<<< 
 * 
 *     def __repr__(self):
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("intbitset.intbitset.__ixor__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_n_endswith;

static PyObject *__pyx_k45p;
static PyObject *__pyx_k46p;
static PyObject *__pyx_k47p;
static PyObject *__pyx_k48p;
static PyObject *__pyx_k49p;
static PyObject *__pyx_k50p;
static PyObject *__pyx_k51p;
static PyObject *__pyx_k52p;
static PyObject *__pyx_k53p;

static char (__pyx_k45[]) = "intbitset([";
static char (__pyx_k46[]) = "%i, ";
static char (__pyx_k47[]) = ", ";
static char (__pyx_k48[]) = "], trailing_bits=True)";
static char (__pyx_k49[]) = "intbitset([";
static char (__pyx_k50[]) = "%i, ";
static char (__pyx_k51[]) = "-2, ";
static char (__pyx_k52[]) = ", ";
static char (__pyx_k53[]) = "])";

static PyObject *__pyx_f_py_9intbitset_9intbitset___repr__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___repr__(PyObject *__pyx_v_self) {
  int __pyx_v_last;
  int __pyx_v_maxelem;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  word_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  PyObject *__pyx_5 = 0;
  Py_ssize_t __pyx_6;
  Py_INCREF(__pyx_v_self);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":337
 *         cdef int last
 *         cdef int maxelem
 *         if self.bitset.trailing_bits:             # <<<<<<<<<<<<<< 
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize
 *             ret = "intbitset(["
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":338
 *         cdef int maxelem
 *         if self.bitset.trailing_bits:
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize             # <<<<<<<<<<<<<< 
 *             ret = "intbitset(["
 *             last = -1
 */
    __pyx_v_maxelem = (intBitSetGetSize(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset) * wordbitsize);

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":339
 *         if self.bitset.trailing_bits:
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize
 *             ret = "intbitset(["             # <<<<<<<<<<<<<< 
 *             last = -1
 *             while last < maxelem:
 */
    Py_INCREF(__pyx_k45p);
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_k45p;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":340
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize
 *             ret = "intbitset(["
 *             last = -1             # <<<<<<<<<<<<<< 
 *             while last < maxelem:
 *                 last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = -1;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":341
 *             ret = "intbitset(["
 *             last = -1
 *             while last < maxelem:             # <<<<<<<<<<<<<< 
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 */
    while (1) {
      __pyx_2 = (__pyx_v_last < __pyx_v_maxelem);
      if (!__pyx_2) break;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":342
 *             last = -1
 *             while last < maxelem:
 *                 last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<< 
 *                 ret = ret + '%i, ' % last
 *             if ret.endswith(", "):
 */
      __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_last);

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":343
 *             while last < maxelem:
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last             # <<<<<<<<<<<<<< 
 *             if ret.endswith(", "):
 *                 ret = ret[:-2]
 */
      __pyx_3 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k46p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; goto __pyx_L1;}
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_3;
      __pyx_3 = 0;
    }

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":344
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 *             if ret.endswith(", "):             # <<<<<<<<<<<<<< 
 *                 ret = ret[:-2]
 *             ret = ret + '], trailing_bits=True)'
 */
    __pyx_4 = PyObject_GetAttr(__pyx_v_ret, __pyx_n_endswith); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; goto __pyx_L1;}
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; goto __pyx_L1;}
    Py_INCREF(__pyx_k47p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k47p);
    __pyx_5 = PyObject_CallObject(__pyx_4, __pyx_3); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_5); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; goto __pyx_L1;}
    Py_DECREF(__pyx_5); __pyx_5 = 0;
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":345
 *                 ret = ret + '%i, ' % last
 *             if ret.endswith(", "):
 *                 ret = ret[:-2]             # <<<<<<<<<<<<<< 
 *             ret = ret + '], trailing_bits=True)'
 *             return ret
 */
      __pyx_4 = PySequence_GetSlice(__pyx_v_ret, 0, -2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 345; goto __pyx_L1;}
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_4;
      __pyx_4 = 0;
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":346
 *             if ret.endswith(", "):
 *                 ret = ret[:-2]
 *             ret = ret + '], trailing_bits=True)'             # <<<<<<<<<<<<<< 
 *             return ret
 *         else:
 */
    __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_k48p); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_3;
    __pyx_3 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":347
 *                 ret = ret[:-2]
 *             ret = ret + '], trailing_bits=True)'
 *             return ret             # <<<<<<<<<<<<<< 
 *         else:
 *             ret = "intbitset(["
 */
    Py_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":349
 *             return ret
 *         else:
 *             ret = "intbitset(["             # <<<<<<<<<<<<<< 
 *             last = -1
 *             while last >= -1:
 */
    Py_INCREF(__pyx_k49p);
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_k49p;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":350
 *         else:
 *             ret = "intbitset(["
 *             last = -1             # <<<<<<<<<<<<<< 
 *             while last >= -1:
 *                 last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = -1;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":351
 *             ret = "intbitset(["
 *             last = -1
 *             while last >= -1:             # <<<<<<<<<<<<<< 
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 */
    while (1) {
      __pyx_2 = (__pyx_v_last >= -1);
      if (!__pyx_2) break;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":352
 *             last = -1
 *             while last >= -1:
 *                 last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<< 
 *                 ret = ret + '%i, ' % last
 *             ret = ret[:-len('-2, ')]
 */
      __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_last);

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":353
 *             while last >= -1:
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last             # <<<<<<<<<<<<<< 
 *             ret = ret[:-len('-2, ')]
 *             if ret.endswith(', '):
 */
      __pyx_5 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 353; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k50p, __pyx_5); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 353; goto __pyx_L1;}
      Py_DECREF(__pyx_5); __pyx_5 = 0;
      __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 353; goto __pyx_L1;}
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_3;
      __pyx_3 = 0;
    }

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":354
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 *             ret = ret[:-len('-2, ')]             # <<<<<<<<<<<<<< 
 *             if ret.endswith(', '):
 *                 ret = ret[:-2]
 */
    __pyx_6 = PyObject_Size(__pyx_k51p); if (unlikely(__pyx_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 354; goto __pyx_L1;}
    __pyx_5 = PySequence_GetSlice(__pyx_v_ret, 0, (-__pyx_6)); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 354; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_5;
    __pyx_5 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":355
 *                 ret = ret + '%i, ' % last
 *             ret = ret[:-len('-2, ')]
 *             if ret.endswith(', '):             # <<<<<<<<<<<<<< 
 *                 ret = ret[:-2]
 *             ret = ret + '])'
 */
    __pyx_4 = PyObject_GetAttr(__pyx_v_ret, __pyx_n_endswith); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; goto __pyx_L1;}
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; goto __pyx_L1;}
    Py_INCREF(__pyx_k52p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k52p);
    __pyx_5 = PyObject_CallObject(__pyx_4, __pyx_3); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_5); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; goto __pyx_L1;}
    Py_DECREF(__pyx_5); __pyx_5 = 0;
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":356
 *             ret = ret[:-len('-2, ')]
 *             if ret.endswith(', '):
 *                 ret = ret[:-2]             # <<<<<<<<<<<<<< 
 *             ret = ret + '])'
 *             return ret
 */
      __pyx_4 = PySequence_GetSlice(__pyx_v_ret, 0, -2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 356; goto __pyx_L1;}
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_4;
      __pyx_4 = 0;
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":357
 *             if ret.endswith(', '):
 *                 ret = ret[:-2]
 *             ret = ret + '])'             # <<<<<<<<<<<<<< 
 *             return ret
 * 
 */
    __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_k53p); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_3;
    __pyx_3 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":358
 *                 ret = ret[:-2]
 *             ret = ret + '])'
 *             return ret             # <<<<<<<<<<<<<< 
 * 
 *     def __str__(self):
 */
    Py_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
  }
  __pyx_L2:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_5);
  __Pyx_AddTraceback("intbitset.intbitset.__repr__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_num_10;
static PyObject *__pyx_num_5;

static PyObject *__pyx_k54p;
static PyObject *__pyx_k55p;
static PyObject *__pyx_k56p;
static PyObject *__pyx_k57p;
static PyObject *__pyx_k58p;
static PyObject *__pyx_k59p;
static PyObject *__pyx_k60p;
static PyObject *__pyx_k61p;

static char (__pyx_k54[]) = "intbitset([";
static char (__pyx_k55[]) = "%i, ";
static char (__pyx_k56[]) = "...])";
static char (__pyx_k57[]) = "intbitset([";
static char (__pyx_k58[]) = "%i, ";
static char (__pyx_k59[]) = "..., ";
static char (__pyx_k60[]) = "%i, ";
static char (__pyx_k61[]) = "])";

static PyObject *__pyx_f_py_9intbitset_9intbitset___str__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___str__(PyObject *__pyx_v_self) {
  int __pyx_v_tot;
  PyObject *__pyx_v_begin_list;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_v_n;
  PyObject *__pyx_v_end_list;
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_ssize_t __pyx_5;
  PyObject *__pyx_6 = 0;
  Py_INCREF(__pyx_v_self);
  __pyx_v_begin_list = Py_None; Py_INCREF(Py_None);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);
  __pyx_v_n = Py_None; Py_INCREF(Py_None);
  __pyx_v_end_list = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":362
 *     def __str__(self):
 *         cdef int tot
 *         tot = intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<< 
 *         if tot < 0:
 *             begin_list = self.to_sorted_list(0, 10)
 */
  __pyx_v_tot = intBitSetGetTot(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":363
 *         cdef int tot
 *         tot = intBitSetGetTot(self.bitset)
 *         if tot < 0:             # <<<<<<<<<<<<<< 
 *             begin_list = self.to_sorted_list(0, 10)
 *             ret = "intbitset(["
 */
  __pyx_1 = (__pyx_v_tot < 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":364
 *         tot = intBitSetGetTot(self.bitset)
 *         if tot < 0:
 *             begin_list = self.to_sorted_list(0, 10)             # <<<<<<<<<<<<<< 
 *             ret = "intbitset(["
 *             for n in begin_list:
 */
    __pyx_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_to_sorted_list); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; goto __pyx_L1;}
    __pyx_3 = PyTuple_New(2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; goto __pyx_L1;}
    Py_INCREF(__pyx_num_0);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_num_0);
    Py_INCREF(__pyx_num_10);
    PyTuple_SET_ITEM(__pyx_3, 1, __pyx_num_10);
    __pyx_4 = PyObject_CallObject(__pyx_2, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    Py_DECREF(__pyx_v_begin_list);
    __pyx_v_begin_list = __pyx_4;
    __pyx_4 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":365
 *         if tot < 0:
 *             begin_list = self.to_sorted_list(0, 10)
 *             ret = "intbitset(["             # <<<<<<<<<<<<<< 
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 */
    Py_INCREF(__pyx_k54p);
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_k54p;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":366
 *             begin_list = self.to_sorted_list(0, 10)
 *             ret = "intbitset(["
 *             for n in begin_list:             # <<<<<<<<<<<<<< 
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "...])"
 */
    if (PyList_CheckExact(__pyx_v_begin_list)) { __pyx_5 = 0; __pyx_2 = __pyx_v_begin_list; Py_INCREF(__pyx_2); }
    else { __pyx_2 = PyObject_GetIter(__pyx_v_begin_list); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 366; goto __pyx_L1;} }
    for (;;) {
      if (PyList_CheckExact(__pyx_2)) { if (__pyx_5 >= PyList_GET_SIZE(__pyx_2)) break; __pyx_3 = PyList_GET_ITEM(__pyx_2, __pyx_5++); Py_INCREF(__pyx_3); }
      else {
        __pyx_3 = PyIter_Next(__pyx_2);
        if (!__pyx_3) {
          break;
        }
      }
      Py_DECREF(__pyx_v_n);
      __pyx_v_n = __pyx_3;
      __pyx_3 = 0;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":367
 *             ret = "intbitset(["
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n             # <<<<<<<<<<<<<< 
 *             ret = ret + "...])"
 *             return ret
 */
      __pyx_4 = PyNumber_Remainder(__pyx_k55p, __pyx_v_n); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; goto __pyx_L1;}
      __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 367; goto __pyx_L1;}
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_3;
      __pyx_3 = 0;
    }
    Py_DECREF(__pyx_2); __pyx_2 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":368
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "...])"             # <<<<<<<<<<<<<< 
 *             return ret
 *         elif tot > 10:
 */
    __pyx_4 = PyNumber_Add(__pyx_v_ret, __pyx_k56p); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 368; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_4;
    __pyx_4 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":369
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "...])"
 *             return ret             # <<<<<<<<<<<<<< 
 *         elif tot > 10:
 *             begin_list = self.to_sorted_list(0, 5)
 */
    Py_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_1 = (__pyx_v_tot > 10);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":371
 *             return ret
 *         elif tot > 10:
 *             begin_list = self.to_sorted_list(0, 5)             # <<<<<<<<<<<<<< 
 *             end_list = self.to_sorted_list(tot - 5, tot)
 *             ret = "intbitset(["
 */
    __pyx_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n_to_sorted_list); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; goto __pyx_L1;}
    __pyx_2 = PyTuple_New(2); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; goto __pyx_L1;}
    Py_INCREF(__pyx_num_0);
    PyTuple_SET_ITEM(__pyx_2, 0, __pyx_num_0);
    Py_INCREF(__pyx_num_5);
    PyTuple_SET_ITEM(__pyx_2, 1, __pyx_num_5);
    __pyx_4 = PyObject_CallObject(__pyx_3, __pyx_2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 371; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    Py_DECREF(__pyx_v_begin_list);
    __pyx_v_begin_list = __pyx_4;
    __pyx_4 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":372
 *         elif tot > 10:
 *             begin_list = self.to_sorted_list(0, 5)
 *             end_list = self.to_sorted_list(tot - 5, tot)             # <<<<<<<<<<<<<< 
 *             ret = "intbitset(["
 *             for n in begin_list:
 */
    __pyx_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n_to_sorted_list); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; goto __pyx_L1;}
    __pyx_2 = PyInt_FromLong((__pyx_v_tot - 5)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; goto __pyx_L1;}
    __pyx_4 = PyInt_FromLong(__pyx_v_tot); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; goto __pyx_L1;}
    __pyx_6 = PyTuple_New(2); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; goto __pyx_L1;}
    PyTuple_SET_ITEM(__pyx_6, 0, __pyx_2);
    PyTuple_SET_ITEM(__pyx_6, 1, __pyx_4);
    __pyx_2 = 0;
    __pyx_4 = 0;
    __pyx_2 = PyObject_CallObject(__pyx_3, __pyx_6); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    Py_DECREF(__pyx_6); __pyx_6 = 0;
    Py_DECREF(__pyx_v_end_list);
    __pyx_v_end_list = __pyx_2;
    __pyx_2 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":373
 *             begin_list = self.to_sorted_list(0, 5)
 *             end_list = self.to_sorted_list(tot - 5, tot)
 *             ret = "intbitset(["             # <<<<<<<<<<<<<< 
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 */
    Py_INCREF(__pyx_k57p);
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_k57p;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":374
 *             end_list = self.to_sorted_list(tot - 5, tot)
 *             ret = "intbitset(["
 *             for n in begin_list:             # <<<<<<<<<<<<<< 
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "..., "
 */
    if (PyList_CheckExact(__pyx_v_begin_list)) { __pyx_5 = 0; __pyx_4 = __pyx_v_begin_list; Py_INCREF(__pyx_4); }
    else { __pyx_4 = PyObject_GetIter(__pyx_v_begin_list); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; goto __pyx_L1;} }
    for (;;) {
      if (PyList_CheckExact(__pyx_4)) { if (__pyx_5 >= PyList_GET_SIZE(__pyx_4)) break; __pyx_3 = PyList_GET_ITEM(__pyx_4, __pyx_5++); Py_INCREF(__pyx_3); }
      else {
        __pyx_3 = PyIter_Next(__pyx_4);
        if (!__pyx_3) {
          break;
        }
      }
      Py_DECREF(__pyx_v_n);
      __pyx_v_n = __pyx_3;
      __pyx_3 = 0;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":375
 *             ret = "intbitset(["
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n             # <<<<<<<<<<<<<< 
 *             ret = ret + "..., "
 *             for n in end_list:
 */
      __pyx_6 = PyNumber_Remainder(__pyx_k58p, __pyx_v_n); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; goto __pyx_L1;}
      __pyx_2 = PyNumber_Add(__pyx_v_ret, __pyx_6); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; goto __pyx_L1;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_2;
      __pyx_2 = 0;
    }
    Py_DECREF(__pyx_4); __pyx_4 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":376
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "..., "             # <<<<<<<<<<<<<< 
 *             for n in end_list:
 *                 ret = ret + '%i, ' % n
 */
    __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_k59p); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_3;
    __pyx_3 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":377
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "..., "
 *             for n in end_list:             # <<<<<<<<<<<<<< 
 *                 ret = ret + '%i, ' % n
 *             ret = ret[:-2]
 */
    if (PyList_CheckExact(__pyx_v_end_list)) { __pyx_5 = 0; __pyx_6 = __pyx_v_end_list; Py_INCREF(__pyx_6); }
    else { __pyx_6 = PyObject_GetIter(__pyx_v_end_list); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; goto __pyx_L1;} }
    for (;;) {
      if (PyList_CheckExact(__pyx_6)) { if (__pyx_5 >= PyList_GET_SIZE(__pyx_6)) break; __pyx_2 = PyList_GET_ITEM(__pyx_6, __pyx_5++); Py_INCREF(__pyx_2); }
      else {
        __pyx_2 = PyIter_Next(__pyx_6);
        if (!__pyx_2) {
          break;
        }
      }
      Py_DECREF(__pyx_v_n);
      __pyx_v_n = __pyx_2;
      __pyx_2 = 0;

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":378
 *             ret = ret + "..., "
 *             for n in end_list:
 *                 ret = ret + '%i, ' % n             # <<<<<<<<<<<<<< 
 *             ret = ret[:-2]
 *             ret = ret + '])'
 */
      __pyx_4 = PyNumber_Remainder(__pyx_k60p, __pyx_v_n); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; goto __pyx_L1;}
      __pyx_3 = PyNumber_Add(__pyx_v_ret, __pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; goto __pyx_L1;}
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      Py_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_3;
      __pyx_3 = 0;
    }
    Py_DECREF(__pyx_6); __pyx_6 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":379
 *             for n in end_list:
 *                 ret = ret + '%i, ' % n
 *             ret = ret[:-2]             # <<<<<<<<<<<<<< 
 *             ret = ret + '])'
 *             return ret
 */
    __pyx_2 = PySequence_GetSlice(__pyx_v_ret, 0, -2); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_2;
    __pyx_2 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":380
 *                 ret = ret + '%i, ' % n
 *             ret = ret[:-2]
 *             ret = ret + '])'             # <<<<<<<<<<<<<< 
 *             return ret
 *         else:
 */
    __pyx_4 = PyNumber_Add(__pyx_v_ret, __pyx_k61p); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; goto __pyx_L1;}
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_4;
    __pyx_4 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":381
 *             ret = ret[:-2]
 *             ret = ret + '])'
 *             return ret             # <<<<<<<<<<<<<< 
 *         else:
 *             return self.__repr__()
 */
    Py_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":383
 *             return ret
 *         else:
 *             return self.__repr__()             # <<<<<<<<<<<<<< 
 * 
 *     ## Buffer interface
 */
    __pyx_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n___repr__); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; goto __pyx_L1;}
    __pyx_6 = PyObject_CallObject(__pyx_3, 0); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __pyx_r = __pyx_6;
    __pyx_6 = 0;
    goto __pyx_L0;
  }
  __pyx_L2:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_6);
  __Pyx_AddTraceback("intbitset.intbitset.__str__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_begin_list);
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_n);
  Py_DECREF(__pyx_v_end_list);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k62p;

static char (__pyx_k62[]) = "It's impossible to iterate over an infinite set.";

static PyObject *__pyx_f_py_9intbitset_9intbitset___iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset___iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  word_t __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":411
 *     # Iterator interface
 *     def __iter__(self):
 *         if self.bitset.trailing_bits:             # <<<<<<<<<<<<<< 
 *             raise OverflowError, "It's impossible to iterate over an infinite set."
 *         return intbitset_iterator(self)
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":412
 *     def __iter__(self):
 *         if self.bitset.trailing_bits:
 *             raise OverflowError, "It's impossible to iterate over an infinite set."             # <<<<<<<<<<<<<< 
 *         return intbitset_iterator(self)
 * 
 */
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_k62p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":413
 *         if self.bitset.trailing_bits:
 *             raise OverflowError, "It's impossible to iterate over an infinite set."
 *         return intbitset_iterator(self)             # <<<<<<<<<<<<<< 
 * 
 *     # Customized interface
 */
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; goto __pyx_L1;}
  Py_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_self);
  __pyx_3 = PyObject_CallObject(((PyObject*)__pyx_ptype_9intbitset_intbitset_iterator), __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.__iter__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k63p;
static PyObject *__pyx_k64p;

static char (__pyx_k63[]) = "Negative numbers, not allowed";
static char (__pyx_k64[]) = "Element must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset_add(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_add[] = "Add an element to a set.\n        This has no effect if the element is already present.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_add(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r;
  bool_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  assert(__pyx_arg_elem); {
    __pyx_v_elem = PyInt_AsLong(__pyx_arg_elem); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; goto __pyx_L1;}
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":419
 *         """Add an element to a set.
 *         This has no effect if the element is already present."""
 *         if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":420
 *         This has no effect if the element is already present."""
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 */
    __pyx_2 = (__pyx_v_elem < 0);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":421
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 */
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k63p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_2 = (__pyx_v_elem > maxelem);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":423
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         intBitSetAddElem(self.bitset, elem)
 * 
 */
      __pyx_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k64p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_L3:;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":424
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 *         intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 * 
 *     def clear(self):
 */
  intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.add");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_clear(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset_clear(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":427
 * 
 *     def clear(self):
 *         intBitSetReset(self.bitset)             # <<<<<<<<<<<<<< 
 * 
 *     def difference(intbitset self, rhs):
 */
  intBitSetReset(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_difference[] = "Return the difference of two intbitsets as a new set.\n        (i.e. all elements that are in this intbitset but not the other.)\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":433
 *         (i.e. all elements that are in this intbitset but not the other.)
 *         """
 *         return self.__sub__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def difference_update(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___sub__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.difference");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_difference_update[] = "Remove all elements of another set from this set.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":437
 *     def difference_update(self, rhs):
 *         """Remove all elements of another set from this set."""
 *         self.__isub__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def discard(self, int elem):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___isub__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.difference_update");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_k65p;
static PyObject *__pyx_k66p;

static char (__pyx_k65[]) = "Negative numbers, not allowed";
static char (__pyx_k66[]) = "Element must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset_discard(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_discard[] = "Remove an element from a intbitset if it is a member.\n        If the element is not a member, do nothing.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_discard(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r;
  bool_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  assert(__pyx_arg_elem); {
    __pyx_v_elem = PyInt_AsLong(__pyx_arg_elem); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; goto __pyx_L1;}
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":442
 *         """Remove an element from a intbitset if it is a member.
 *         If the element is not a member, do nothing."""
 *         if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":443
 *         If the element is not a member, do nothing."""
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 */
    __pyx_2 = (__pyx_v_elem < 0);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":444
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 */
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k65p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_2 = (__pyx_v_elem > maxelem);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":446
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         intBitSetDelElem(self.bitset, elem)
 * 
 */
      __pyx_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k66p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_L3:;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":447
 *             elif elem > maxelem:
 *                 raise OverflowError, "Element must be <= %s" % maxelem
 *         intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 * 
 *     def intersection(self, rhs):
 */
  intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.discard");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_intersection(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_intersection[] = "Return the intersection of two intbitsets as a new set.\n        (i.e. all elements that are in both intbitsets.)\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_intersection(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":453
 *         (i.e. all elements that are in both intbitsets.)
 *         """
 *         return self.__and__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def intersection_update(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___and__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.intersection");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_intersection_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_intersection_update[] = "Update a intbitset with the intersection of itself and another.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_intersection_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":457
 *     def intersection_update(self, rhs):
 *         """Update a intbitset with the intersection of itself and another."""
 *         self.__iand__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def union(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___iand__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.intersection_update");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_union(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_union[] = "Return the union of two intbitsets as a new set.\n        (i.e. all elements that are in either intbitsets.)\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_union(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":463
 *         (i.e. all elements that are in either intbitsets.)
 *         """
 *         return self.__or__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def union_update(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___or__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 463; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 463; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 463; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.union");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_union_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_union_update[] = "Update a intbitset with the union of itself and another.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_union_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":467
 *     def union_update(self, rhs):
 *         """Update a intbitset with the union of itself and another."""
 *         self.__ior__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def issubset(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___ior__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.union_update");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_n___le__;

static PyObject *__pyx_f_py_9intbitset_9intbitset_issubset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_issubset[] = "Report whether another set contains this set.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_issubset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":471
 *     def issubset(self, rhs):
 *         """Report whether another set contains this set."""
 *         return self.__le__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def issuperset(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___le__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.issubset");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_n___ge__;

static PyObject *__pyx_f_py_9intbitset_9intbitset_issuperset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_issuperset[] = "Report whether this set contains another set.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_issuperset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":475
 *     def issuperset(self, rhs):
 *         """Report whether this set contains another set."""
 *         return self.__ge__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def symmetric_difference(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___ge__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.issuperset");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_symmetric_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_symmetric_difference[] = "Return the symmetric difference of two sets as a new set.\n        (i.e. all elements that are in exactly one of the sets.)\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_symmetric_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":481
 *         (i.e. all elements that are in exactly one of the sets.)
 *         """
 *         return self.__xor__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     def symmetric_difference_update(self, rhs):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___xor__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 481; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 481; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 481; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.symmetric_difference");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_symmetric_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_symmetric_difference_update[] = "Update an intbitset with the symmetric difference of itself and another.\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_symmetric_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":486
 *         """Update an intbitset with the symmetric difference of itself and another.
 *         """
 *         self.__ixor__(rhs)             # <<<<<<<<<<<<<< 
 * 
 *     # Dumping & Loading
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n___ixor__); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; goto __pyx_L1;}
  Py_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_rhs);
  __pyx_3 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.symmetric_difference_update");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_n_compress;

static PyObject *__pyx_f_py_9intbitset_9intbitset_fastdump(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_fastdump[] = "Return a compressed string representation suitable to be saved\n        somewhere.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_fastdump(PyObject *__pyx_v_self, PyObject *unused) {
  Py_ssize_t __pyx_v_size;
  PyObject *__pyx_v_tmp;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);
  __pyx_v_tmp = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":493
 *         somewhere."""
 *         cdef Py_ssize_t size
 *         size = intBitSetGetSize((<intbitset> self).bitset)             # <<<<<<<<<<<<<< 
 *         tmp = PyString_FromStringAndSize(<char *>self.bitset.bitset, ( size + 1) * wordbytesize)
 *         return zlib.compress(tmp)
 */
  __pyx_v_size = intBitSetGetSize(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":494
 *         cdef Py_ssize_t size
 *         size = intBitSetGetSize((<intbitset> self).bitset)
 *         tmp = PyString_FromStringAndSize(<char *>self.bitset.bitset, ( size + 1) * wordbytesize)             # <<<<<<<<<<<<<< 
 *         return zlib.compress(tmp)
 * 
 */
  __pyx_1 = PyString_FromStringAndSize(((char (*))((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->bitset),((__pyx_v_size + 1) * wordbytesize)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; goto __pyx_L1;}
  Py_DECREF(__pyx_v_tmp);
  __pyx_v_tmp = __pyx_1;
  __pyx_1 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":495
 *         size = intBitSetGetSize((<intbitset> self).bitset)
 *         tmp = PyString_FromStringAndSize(<char *>self.bitset.bitset, ( size + 1) * wordbytesize)
 *         return zlib.compress(tmp)             # <<<<<<<<<<<<<< 
 * 
 *     def fastload(self, strdump):
 */
  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_n_zlib); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; goto __pyx_L1;}
  __pyx_2 = PyObject_GetAttr(__pyx_1, __pyx_n_compress); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_1 = PyTuple_New(1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; goto __pyx_L1;}
  Py_INCREF(__pyx_v_tmp);
  PyTuple_SET_ITEM(__pyx_1, 0, __pyx_v_tmp);
  __pyx_3 = PyObject_CallObject(__pyx_2, __pyx_1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.fastdump");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_tmp);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k67p;

static char (__pyx_k67[]) = "strdump is corrupted";

static PyObject *__pyx_f_py_9intbitset_9intbitset_fastload(PyObject *__pyx_v_self, PyObject *__pyx_v_strdump); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_fastload[] = "Load a compressed string representation produced by a previous call\n        to the fastdump method into the current intbitset. The previous content\n        will be replaced.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_fastload(PyObject *__pyx_v_self, PyObject *__pyx_v_strdump) {
  Py_ssize_t __pyx_v_size;
  void (*__pyx_v_buf);
  PyObject *__pyx_v_tmp;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  int __pyx_3;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_strdump);
  __pyx_v_tmp = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":503
 *         cdef Py_ssize_t size
 *         cdef void *buf
 *         buf = NULL             # <<<<<<<<<<<<<< 
 *         size = 0
 *         try:
 */
  __pyx_v_buf = NULL;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":504
 *         cdef void *buf
 *         buf = NULL
 *         size = 0             # <<<<<<<<<<<<<< 
 *         try:
 *             if type(strdump) is array:
 */
  __pyx_v_size = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":505
 *         buf = NULL
 *         size = 0
 *         try:             # <<<<<<<<<<<<<< 
 *             if type(strdump) is array:
 *                 strdump = strdump.tostring()
 */
  /*try:*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":506
 *         size = 0
 *         try:
 *             if type(strdump) is array:             # <<<<<<<<<<<<<< 
 *                 strdump = strdump.tostring()
 *             # tmp needed to not be garbage collected
 */
    __pyx_1 = PyTuple_New(1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; goto __pyx_L2;}
    Py_INCREF(__pyx_v_strdump);
    PyTuple_SET_ITEM(__pyx_1, 0, __pyx_v_strdump);
    __pyx_2 = PyObject_CallObject(((PyObject*)&PyType_Type), __pyx_1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; goto __pyx_L2;}
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_n_array); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; goto __pyx_L2;}
    __pyx_3 = (__pyx_2 == __pyx_1);
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    if (__pyx_3) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":507
 *         try:
 *             if type(strdump) is array:
 *                 strdump = strdump.tostring()             # <<<<<<<<<<<<<< 
 *             # tmp needed to not be garbage collected
 *             tmp = zlib.decompress(strdump)
 */
      __pyx_2 = PyObject_GetAttr(__pyx_v_strdump, __pyx_n_tostring); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; goto __pyx_L2;}
      __pyx_1 = PyObject_CallObject(__pyx_2, 0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; goto __pyx_L2;}
      Py_DECREF(__pyx_2); __pyx_2 = 0;
      Py_DECREF(__pyx_v_strdump);
      __pyx_v_strdump = __pyx_1;
      __pyx_1 = 0;
      goto __pyx_L4;
    }
    __pyx_L4:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":509
 *                 strdump = strdump.tostring()
 *             # tmp needed to not be garbage collected
 *             tmp = zlib.decompress(strdump)             # <<<<<<<<<<<<<< 
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                 raise Exception
 */
    __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_zlib); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; goto __pyx_L2;}
    __pyx_1 = PyObject_GetAttr(__pyx_2, __pyx_n_decompress); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; goto __pyx_L2;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; goto __pyx_L2;}
    Py_INCREF(__pyx_v_strdump);
    PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_strdump);
    __pyx_4 = PyObject_CallObject(__pyx_1, __pyx_2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; goto __pyx_L2;}
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    Py_DECREF(__pyx_v_tmp);
    __pyx_v_tmp = __pyx_4;
    __pyx_4 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":510
 *             # tmp needed to not be garbage collected
 *             tmp = zlib.decompress(strdump)
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:             # <<<<<<<<<<<<<< 
 *                 raise Exception
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 */
    __pyx_3 = (PyObject_AsReadBuffer(__pyx_v_tmp,(&__pyx_v_buf),(&__pyx_v_size)) < 0);
    if (__pyx_3) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":511
 *             tmp = zlib.decompress(strdump)
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                 raise Exception             # <<<<<<<<<<<<<< 
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 *         except:
 */
      __Pyx_Raise(__pyx_builtin_Exception, 0, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; goto __pyx_L2;}
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":512
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                 raise Exception
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)             # <<<<<<<<<<<<<< 
 *         except:
 *             raise ValueError, "strdump is corrupted"
 */
    intBitSetResetFromBuffer(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_buf,__pyx_v_size);
  }
  goto __pyx_L3;
  __pyx_L2:;
  Py_XDECREF(__pyx_1); __pyx_1 = 0;
  Py_XDECREF(__pyx_2); __pyx_2 = 0;
  Py_XDECREF(__pyx_4); __pyx_4 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":513
 *                 raise Exception
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 *         except:             # <<<<<<<<<<<<<< 
 *             raise ValueError, "strdump is corrupted"
 *         return self
 */
  /*except:*/ {
    __Pyx_AddTraceback("intbitset.fastload");
    __pyx_1 = __Pyx_GetExcValue(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; goto __pyx_L1;}
    Py_DECREF(__pyx_1); __pyx_1 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":514
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 *         except:
 *             raise ValueError, "strdump is corrupted"             # <<<<<<<<<<<<<< 
 *         return self
 * 
 */
    __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k67p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 514; goto __pyx_L1;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":515
 *         except:
 *             raise ValueError, "strdump is corrupted"
 *         return self             # <<<<<<<<<<<<<< 
 * 
 *     def copy(self):
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.fastload");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_tmp);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_strdump);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_copy(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_copy[] = "Return a shallow copy of a set.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_copy(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":519
 *     def copy(self):
 *         """Return a shallow copy of a set."""
 *         return intbitset(self)             # <<<<<<<<<<<<<< 
 * 
 *     def pop(self):
 */
  __pyx_1 = PyTuple_New(1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; goto __pyx_L1;}
  Py_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_1, 0, __pyx_v_self);
  __pyx_2 = PyObject_CallObject(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_2;
  __pyx_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("intbitset.intbitset.copy");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_n_KeyError;

static PyObject *__pyx_k68p;

static PyObject *__pyx_builtin_KeyError;

static char (__pyx_k68[]) = "pop from an empty intbitset";

static PyObject *__pyx_f_py_9intbitset_9intbitset_pop(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_pop[] = "Remove and return an arbitrary set element.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_pop(PyObject *__pyx_v_self, PyObject *unused) {
  int __pyx_v_ret;
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":524
 *         """Remove and return an arbitrary set element."""
 *         cdef int ret
 *         ret = intBitSetGetNext(self.bitset, -1)             # <<<<<<<<<<<<<< 
 *         if ret < 0:
 *             raise KeyError, "pop from an empty intbitset"
 */
  __pyx_v_ret = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,-1);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":525
 *         cdef int ret
 *         ret = intBitSetGetNext(self.bitset, -1)
 *         if ret < 0:             # <<<<<<<<<<<<<< 
 *             raise KeyError, "pop from an empty intbitset"
 *         intBitSetDelElem(self.bitset, ret)
 */
  __pyx_1 = (__pyx_v_ret < 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":526
 *         ret = intBitSetGetNext(self.bitset, -1)
 *         if ret < 0:
 *             raise KeyError, "pop from an empty intbitset"             # <<<<<<<<<<<<<< 
 *         intBitSetDelElem(self.bitset, ret)
 *         return ret
 */
    __Pyx_Raise(__pyx_builtin_KeyError, __pyx_k68p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 526; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":527
 *         if ret < 0:
 *             raise KeyError, "pop from an empty intbitset"
 *         intBitSetDelElem(self.bitset, ret)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
  intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_ret);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":528
 *             raise KeyError, "pop from an empty intbitset"
 *         intBitSetDelElem(self.bitset, ret)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def remove(self, int elem):
 */
  __pyx_2 = PyInt_FromLong(__pyx_v_ret); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; goto __pyx_L1;}
  __pyx_r = __pyx_2;
  __pyx_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("intbitset.intbitset.pop");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k69p;
static PyObject *__pyx_k70p;

static char (__pyx_k69[]) = "Negative numbers, not allowed";
static char (__pyx_k70[]) = "Elements must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset_remove(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_remove[] = "Remove an element from a set; it must be a member.\n        If the element is not a member, raise a KeyError.\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_remove(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r;
  bool_t __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  assert(__pyx_arg_elem); {
    __pyx_v_elem = PyInt_AsLong(__pyx_arg_elem); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; goto __pyx_L1;}
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":534
 *         If the element is not a member, raise a KeyError.
 *         """
 *         if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":535
 *         """
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<< 
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 */
    __pyx_2 = (__pyx_v_elem < 0);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":536
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *             elif elem > maxelem:
 *                 raise OverflowError, "Elements must be <= %s" % maxelem
 */
      __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k69p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_2 = (__pyx_v_elem > maxelem);
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":538
 *                 raise ValueError, "Negative numbers, not allowed"
 *             elif elem > maxelem:
 *                 raise OverflowError, "Elements must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         if intBitSetIsInElem(self.bitset, elem):
 *             intBitSetDelElem(self.bitset, elem)
 */
      __pyx_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; goto __pyx_L1;}
      __pyx_4 = PyNumber_Remainder(__pyx_k70p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_L3:;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":539
 *             elif elem > maxelem:
 *                 raise OverflowError, "Elements must be <= %s" % maxelem
 *         if intBitSetIsInElem(self.bitset, elem):             # <<<<<<<<<<<<<< 
 *             intBitSetDelElem(self.bitset, elem)
 *         else:
 */
  __pyx_1 = intBitSetIsInElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":540
 *                 raise OverflowError, "Elements must be <= %s" % maxelem
 *         if intBitSetIsInElem(self.bitset, elem):
 *             intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<< 
 *         else:
 *             raise KeyError, elem
 */
    intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_elem);
    goto __pyx_L4;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":542
 *             intBitSetDelElem(self.bitset, elem)
 *         else:
 *             raise KeyError, elem             # <<<<<<<<<<<<<< 
 * 
 *     def strbits(self):
 */
    __pyx_3 = PyInt_FromLong(__pyx_v_elem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; goto __pyx_L1;}
    __Pyx_Raise(__pyx_builtin_KeyError, __pyx_3, 0);
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; goto __pyx_L1;}
  }
  __pyx_L4:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.remove");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k71p;
static PyObject *__pyx_k72p;
static PyObject *__pyx_k73p;
static PyObject *__pyx_k74p;

static char (__pyx_k71[]) = "It's impossible to print an infinite set.";
static char (__pyx_k72[]) = "";
static char (__pyx_k73[]) = "0";
static char (__pyx_k74[]) = "1";

static PyObject *__pyx_f_py_9intbitset_9intbitset_strbits(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_strbits[] = "Return a string of 0s and 1s representing the content in memory\n        of the intbitset.\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_strbits(PyObject *__pyx_v_self, PyObject *unused) {
  int __pyx_v_i;
  int __pyx_v_last;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  word_t __pyx_1;
  Py_ssize_t __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  PyObject *__pyx_6 = 0;
  Py_INCREF(__pyx_v_self);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":550
 *         cdef int i
 *         cdef int last
 *         if (<intbitset> self).bitset.trailing_bits:             # <<<<<<<<<<<<<< 
 *             raise OverflowError, "It's impossible to print an infinite set."
 *         last = 0
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":551
 *         cdef int last
 *         if (<intbitset> self).bitset.trailing_bits:
 *             raise OverflowError, "It's impossible to print an infinite set."             # <<<<<<<<<<<<<< 
 *         last = 0
 *         ret = ''
 */
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_k71p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":552
 *         if (<intbitset> self).bitset.trailing_bits:
 *             raise OverflowError, "It's impossible to print an infinite set."
 *         last = 0             # <<<<<<<<<<<<<< 
 *         ret = ''
 *         for i in self:
 */
  __pyx_v_last = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":553
 *             raise OverflowError, "It's impossible to print an infinite set."
 *         last = 0
 *         ret = ''             # <<<<<<<<<<<<<< 
 *         for i in self:
 *             ret = ret + '0'*(i-last)+'1'
 */
  Py_INCREF(__pyx_k72p);
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_k72p;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":554
 *         last = 0
 *         ret = ''
 *         for i in self:             # <<<<<<<<<<<<<< 
 *             ret = ret + '0'*(i-last)+'1'
 *             last = i+1
 */
  if (PyList_CheckExact(__pyx_v_self)) { __pyx_2 = 0; __pyx_3 = __pyx_v_self; Py_INCREF(__pyx_3); }
  else { __pyx_3 = PyObject_GetIter(__pyx_v_self); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 554; goto __pyx_L1;} }
  for (;;) {
    if (PyList_CheckExact(__pyx_3)) { if (__pyx_2 >= PyList_GET_SIZE(__pyx_3)) break; __pyx_4 = PyList_GET_ITEM(__pyx_3, __pyx_2++); Py_INCREF(__pyx_4); }
    else {
      __pyx_4 = PyIter_Next(__pyx_3);
      if (!__pyx_4) {
        break;
      }
    }
    __pyx_5 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 554; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    __pyx_v_i = __pyx_5;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":555
 *         ret = ''
 *         for i in self:
 *             ret = ret + '0'*(i-last)+'1'             # <<<<<<<<<<<<<< 
 *             last = i+1
 *         return ret
 */
    __pyx_4 = PyInt_FromLong((__pyx_v_i - __pyx_v_last)); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 555; goto __pyx_L1;}
    __pyx_6 = PyNumber_Multiply(__pyx_k73p, __pyx_4); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 555; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    __pyx_4 = PyNumber_Add(__pyx_v_ret, __pyx_6); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 555; goto __pyx_L1;}
    Py_DECREF(__pyx_6); __pyx_6 = 0;
    __pyx_6 = PyNumber_Add(__pyx_4, __pyx_k74p); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 555; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    Py_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_6;
    __pyx_6 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":556
 *         for i in self:
 *             ret = ret + '0'*(i-last)+'1'
 *             last = i+1             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
    __pyx_v_last = (__pyx_v_i + 1);
  }
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":557
 *             ret = ret + '0'*(i-last)+'1'
 *             last = i+1
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def update_with_signs(self, rhs):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_6);
  __Pyx_AddTraceback("intbitset.intbitset.strbits");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_n_iteritems;
static PyObject *__pyx_n_AttributeError;

static PyObject *__pyx_k75p;
static PyObject *__pyx_k76p;
static PyObject *__pyx_k77p;

static PyObject *__pyx_builtin_AttributeError;

static char (__pyx_k75[]) = "Negative numbers, not allowed";
static char (__pyx_k76[]) = "Elements must <= %s";
static char (__pyx_k77[]) = "rhs should be a valid dictionary with integers keys and integer values";

static PyObject *__pyx_f_py_9intbitset_9intbitset_update_with_signs(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_update_with_signs[] = "Given a dictionary rhs whose keys are integers, remove all the integers\n        whose value are less than 0 and add every integer whose value is 0 or more";
static PyObject *__pyx_f_py_9intbitset_9intbitset_update_with_signs(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_v_value;
  PyObject *__pyx_v_sign;
  PyObject *__pyx_r;
  bool_t __pyx_1;
  Py_ssize_t __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  PyObject *__pyx_5 = 0;
  PyObject *__pyx_6 = 0;
  int __pyx_7;
  int __pyx_8;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_rhs);
  __pyx_v_sign = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":563
 *         whose value are less than 0 and add every integer whose value is 0 or more"""
 *         cdef int value
 *         try:             # <<<<<<<<<<<<<< 
 *             if self.sanity_checks:
 *                 for value, sign in rhs.iteritems():
 */
  /*try:*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":564
 *         cdef int value
 *         try:
 *             if self.sanity_checks:             # <<<<<<<<<<<<<< 
 *                 for value, sign in rhs.iteritems():
 *                     if value < 0:
 */
    __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_1) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":565
 *         try:
 *             if self.sanity_checks:
 *                 for value, sign in rhs.iteritems():             # <<<<<<<<<<<<<< 
 *                     if value < 0:
 *                         raise ValueError, "Negative numbers, not allowed"
 */
      __pyx_3 = PyObject_GetAttr(__pyx_v_rhs, __pyx_n_iteritems); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
      __pyx_4 = PyObject_CallObject(__pyx_3, 0); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      if (PyList_CheckExact(__pyx_4)) { __pyx_2 = 0; __pyx_3 = __pyx_4; Py_INCREF(__pyx_3); }
      else { __pyx_3 = PyObject_GetIter(__pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;} }
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      for (;;) {
        if (PyList_CheckExact(__pyx_3)) { if (__pyx_2 >= PyList_GET_SIZE(__pyx_3)) break; __pyx_4 = PyList_GET_ITEM(__pyx_3, __pyx_2++); Py_INCREF(__pyx_4); }
        else {
          __pyx_4 = PyIter_Next(__pyx_3);
          if (!__pyx_4) {
            break;
          }
        }
        if (PyTuple_CheckExact(__pyx_4) && PyTuple_GET_SIZE(__pyx_4) == 2) {
          __pyx_6 = PyTuple_GET_ITEM(__pyx_4, 0);
          Py_INCREF(__pyx_6);
          __pyx_7 = PyInt_AsLong(__pyx_6); if (unlikely((__pyx_7 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
          Py_DECREF(__pyx_6); __pyx_6 = 0;
          __pyx_v_value = __pyx_7;
          __pyx_6 = PyTuple_GET_ITEM(__pyx_4, 1);
          Py_INCREF(__pyx_6);
          Py_DECREF(__pyx_v_sign);
          __pyx_v_sign = __pyx_6;
          __pyx_6 = 0;
          Py_DECREF(__pyx_4); __pyx_4 = 0;
        }
        else {
          __pyx_5 = PyObject_GetIter(__pyx_4); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          __pyx_6 = __Pyx_UnpackItem(__pyx_5); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
          __pyx_7 = PyInt_AsLong(__pyx_6); if (unlikely((__pyx_7 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
          Py_DECREF(__pyx_6); __pyx_6 = 0;
          __pyx_v_value = __pyx_7;
          __pyx_6 = __Pyx_UnpackItem(__pyx_5); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
          Py_DECREF(__pyx_v_sign);
          __pyx_v_sign = __pyx_6;
          __pyx_6 = 0;
          if (__Pyx_EndUnpack(__pyx_5) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; goto __pyx_L2;}
          Py_DECREF(__pyx_5); __pyx_5 = 0;
        }

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":566
 *             if self.sanity_checks:
 *                 for value, sign in rhs.iteritems():
 *                     if value < 0:             # <<<<<<<<<<<<<< 
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif value > maxelem:
 */
        __pyx_8 = (__pyx_v_value < 0);
        if (__pyx_8) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":567
 *                 for value, sign in rhs.iteritems():
 *                     if value < 0:
 *                         raise ValueError, "Negative numbers, not allowed"             # <<<<<<<<<<<<<< 
 *                     elif value > maxelem:
 *                         raise OverflowError, "Elements must <= %s" % maxelem
 */
          __Pyx_Raise(__pyx_builtin_ValueError, __pyx_k75p, 0);
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; goto __pyx_L2;}
          goto __pyx_L7;
        }
        __pyx_8 = (__pyx_v_value > maxelem);
        if (__pyx_8) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":569
 *                         raise ValueError, "Negative numbers, not allowed"
 *                     elif value > maxelem:
 *                         raise OverflowError, "Elements must <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)
 */
          __pyx_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; goto __pyx_L2;}
          __pyx_4 = PyNumber_Remainder(__pyx_k76p, __pyx_6); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; goto __pyx_L2;}
          Py_DECREF(__pyx_6); __pyx_6 = 0;
          __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; goto __pyx_L2;}
          goto __pyx_L7;
        }
        __pyx_L7:;

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":570
 *                     elif value > maxelem:
 *                         raise OverflowError, "Elements must <= %s" % maxelem
 *                     if sign < 0:             # <<<<<<<<<<<<<< 
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 */
        __pyx_5 = PyObject_RichCompare(__pyx_v_sign, __pyx_num_0, Py_LT); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; goto __pyx_L2;}
        __pyx_8 = __Pyx_PyObject_IsTrue(__pyx_5); if (unlikely(__pyx_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; goto __pyx_L2;}
        Py_DECREF(__pyx_5); __pyx_5 = 0;
        if (__pyx_8) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":571
 *                         raise OverflowError, "Elements must <= %s" % maxelem
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)             # <<<<<<<<<<<<<< 
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)
 */
          intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_value);
          goto __pyx_L8;
        }
        /*else*/ {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":573
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)             # <<<<<<<<<<<<<< 
 *             else:
 *                 for value, sign in rhs.iteritems():
 */
          intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_value);
        }
        __pyx_L8:;
      }
      Py_DECREF(__pyx_3); __pyx_3 = 0;
      goto __pyx_L4;
    }
    /*else*/ {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":575
 *                         intBitSetAddElem(self.bitset, value)
 *             else:
 *                 for value, sign in rhs.iteritems():             # <<<<<<<<<<<<<< 
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)
 */
      __pyx_6 = PyObject_GetAttr(__pyx_v_rhs, __pyx_n_iteritems); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
      __pyx_4 = PyObject_CallObject(__pyx_6, 0); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      if (PyList_CheckExact(__pyx_4)) { __pyx_2 = 0; __pyx_5 = __pyx_4; Py_INCREF(__pyx_5); }
      else { __pyx_5 = PyObject_GetIter(__pyx_4); if (unlikely(!__pyx_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;} }
      Py_DECREF(__pyx_4); __pyx_4 = 0;
      for (;;) {
        if (PyList_CheckExact(__pyx_5)) { if (__pyx_2 >= PyList_GET_SIZE(__pyx_5)) break; __pyx_3 = PyList_GET_ITEM(__pyx_5, __pyx_2++); Py_INCREF(__pyx_3); }
        else {
          __pyx_3 = PyIter_Next(__pyx_5);
          if (!__pyx_3) {
            break;
          }
        }
        if (PyTuple_CheckExact(__pyx_3) && PyTuple_GET_SIZE(__pyx_3) == 2) {
          __pyx_4 = PyTuple_GET_ITEM(__pyx_3, 0);
          Py_INCREF(__pyx_4);
          __pyx_7 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_7 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          __pyx_v_value = __pyx_7;
          __pyx_4 = PyTuple_GET_ITEM(__pyx_3, 1);
          Py_INCREF(__pyx_4);
          Py_DECREF(__pyx_v_sign);
          __pyx_v_sign = __pyx_4;
          __pyx_4 = 0;
          Py_DECREF(__pyx_3); __pyx_3 = 0;
        }
        else {
          __pyx_6 = PyObject_GetIter(__pyx_3); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
          Py_DECREF(__pyx_3); __pyx_3 = 0;
          __pyx_4 = __Pyx_UnpackItem(__pyx_6); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
          __pyx_7 = PyInt_AsLong(__pyx_4); if (unlikely((__pyx_7 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
          Py_DECREF(__pyx_4); __pyx_4 = 0;
          __pyx_v_value = __pyx_7;
          __pyx_4 = __Pyx_UnpackItem(__pyx_6); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
          Py_DECREF(__pyx_v_sign);
          __pyx_v_sign = __pyx_4;
          __pyx_4 = 0;
          if (__Pyx_EndUnpack(__pyx_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; goto __pyx_L2;}
          Py_DECREF(__pyx_6); __pyx_6 = 0;
        }

        /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":576
 *             else:
 *                 for value, sign in rhs.iteritems():
 *                     if sign < 0:             # <<<<<<<<<<<<<< 
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 */
        __pyx_4 = PyObject_RichCompare(__pyx_v_sign, __pyx_num_0, Py_LT); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; goto __pyx_L2;}
        __pyx_8 = __Pyx_PyObject_IsTrue(__pyx_4); if (unlikely(__pyx_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; goto __pyx_L2;}
        Py_DECREF(__pyx_4); __pyx_4 = 0;
        if (__pyx_8) {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":577
 *                 for value, sign in rhs.iteritems():
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)             # <<<<<<<<<<<<<< 
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)
 */
          intBitSetDelElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_value);
          goto __pyx_L11;
        }
        /*else*/ {

          /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":579
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)             # <<<<<<<<<<<<<< 
 *         except AttributeError:
 *             raise TypeError, "rhs should be a valid dictionary with integers keys and integer values"
 */
          intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_value);
        }
        __pyx_L11:;
      }
      Py_DECREF(__pyx_5); __pyx_5 = 0;
    }
    __pyx_L4:;
  }
  goto __pyx_L3;
  __pyx_L2:;
  Py_XDECREF(__pyx_3); __pyx_3 = 0;
  Py_XDECREF(__pyx_6); __pyx_6 = 0;
  Py_XDECREF(__pyx_4); __pyx_4 = 0;
  Py_XDECREF(__pyx_5); __pyx_5 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":580
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)
 *         except AttributeError:             # <<<<<<<<<<<<<< 
 *             raise TypeError, "rhs should be a valid dictionary with integers keys and integer values"
 * 
 */
  __pyx_7 = PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
  if (__pyx_7) {
    __Pyx_AddTraceback("intbitset.update_with_signs");
    __pyx_3 = __Pyx_GetExcValue(); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":581
 *                         intBitSetAddElem(self.bitset, value)
 *         except AttributeError:
 *             raise TypeError, "rhs should be a valid dictionary with integers keys and integer values"             # <<<<<<<<<<<<<< 
 * 
 *     def get_size(self):
 */
    __Pyx_Raise(__pyx_builtin_TypeError, __pyx_k77p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; goto __pyx_L1;}
    goto __pyx_L3;
  }
  goto __pyx_L1;
  __pyx_L3:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_5);
  Py_XDECREF(__pyx_6);
  __Pyx_AddTraceback("intbitset.intbitset.update_with_signs");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_sign);
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_rhs);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_get_size(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset_get_size(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":584
 * 
 *     def get_size(self):
 *         return intBitSetGetSize(self.bitset)             # <<<<<<<<<<<<<< 
 * 
 *     def get_allocated(self):
 */
  __pyx_1 = PyInt_FromLong(intBitSetGetSize(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 584; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("intbitset.intbitset.get_size");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_get_allocated(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset_get_allocated(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":587
 * 
 *     def get_allocated(self):
 *         return intBitSetGetAllocated(self.bitset)             # <<<<<<<<<<<<<< 
 * 
 *     def get_sorted_element(self, int index):
 */
  __pyx_1 = PyInt_FromLong(intBitSetGetAllocated(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("intbitset.intbitset.get_allocated");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_n_IndexError;

static PyObject *__pyx_k78p;
static PyObject *__pyx_k79p;
static PyObject *__pyx_k80p;

static PyObject *__pyx_builtin_IndexError;

static char (__pyx_k78[]) = "It's impossible to retrieve a negative item from an infinite set.";
static char (__pyx_k79[]) = "Index must be <= %s";
static char (__pyx_k80[]) = "intbitset index out of range";

static PyObject *__pyx_f_py_9intbitset_9intbitset_get_sorted_element(PyObject *__pyx_v_self, PyObject *__pyx_arg_index); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_get_sorted_element[] = "Return element at position index in the sorted representation of the\n        set. Note that index must be less than len(self)";
static PyObject *__pyx_f_py_9intbitset_9intbitset_get_sorted_element(PyObject *__pyx_v_self, PyObject *__pyx_arg_index) {
  int __pyx_v_index;
  int __pyx_v_l;
  int __pyx_v_last;
  int __pyx_v_i;
  PyObject *__pyx_r;
  int __pyx_1;
  word_t __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  Py_INCREF(__pyx_v_self);
  assert(__pyx_arg_index); {
    __pyx_v_index = PyInt_AsLong(__pyx_arg_index); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 589; goto __pyx_L1;}
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":595
 *         cdef int last
 *         cdef int i
 *         l = intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<< 
 *         if index < 0:
 *             if self.bitset.trailing_bits:
 */
  __pyx_v_l = intBitSetGetTot(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":596
 *         cdef int i
 *         l = intBitSetGetTot(self.bitset)
 *         if index < 0:             # <<<<<<<<<<<<<< 
 *             if self.bitset.trailing_bits:
 *                 raise OverflowError, "It's impossible to retrieve a negative item from an infinite set."
 */
  __pyx_1 = (__pyx_v_index < 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":597
 *         l = intBitSetGetTot(self.bitset)
 *         if index < 0:
 *             if self.bitset.trailing_bits:             # <<<<<<<<<<<<<< 
 *                 raise OverflowError, "It's impossible to retrieve a negative item from an infinite set."
 *             index = index + l
 */
    __pyx_2 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
    if (__pyx_2) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":598
 *         if index < 0:
 *             if self.bitset.trailing_bits:
 *                 raise OverflowError, "It's impossible to retrieve a negative item from an infinite set."             # <<<<<<<<<<<<<< 
 *             index = index + l
 *         elif index > maxelem:
 */
      __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_k78p, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; goto __pyx_L1;}
      goto __pyx_L3;
    }
    __pyx_L3:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":599
 *             if self.bitset.trailing_bits:
 *                 raise OverflowError, "It's impossible to retrieve a negative item from an infinite set."
 *             index = index + l             # <<<<<<<<<<<<<< 
 *         elif index > maxelem:
 *             raise OverflowError, "Index must be <= %s" % maxelem
 */
    __pyx_v_index = (__pyx_v_index + __pyx_v_l);
    goto __pyx_L2;
  }
  __pyx_1 = (__pyx_v_index > maxelem);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":601
 *             index = index + l
 *         elif index > maxelem:
 *             raise OverflowError, "Index must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         if 0 <= index < l:
 *             last = intBitSetGetNext(self.bitset, -1)
 */
    __pyx_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 601; goto __pyx_L1;}
    __pyx_4 = PyNumber_Remainder(__pyx_k79p, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 601; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_4, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 601; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":602
 *         elif index > maxelem:
 *             raise OverflowError, "Index must be <= %s" % maxelem
 *         if 0 <= index < l:             # <<<<<<<<<<<<<< 
 *             last = intBitSetGetNext(self.bitset, -1)
 *             for i from 0 <= i < index:
 */
  __pyx_1 = (0 <= __pyx_v_index);
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_index < __pyx_v_l);
  }
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":603
 *             raise OverflowError, "Index must be <= %s" % maxelem
 *         if 0 <= index < l:
 *             last = intBitSetGetNext(self.bitset, -1)             # <<<<<<<<<<<<<< 
 *             for i from 0 <= i < index:
 *                 last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,-1);

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":604
 *         if 0 <= index < l:
 *             last = intBitSetGetNext(self.bitset, -1)
 *             for i from 0 <= i < index:             # <<<<<<<<<<<<<< 
 *                 last = intBitSetGetNext(self.bitset, last)
 *         else:
 */
    for (__pyx_v_i = 0; __pyx_v_i < __pyx_v_index; __pyx_v_i++) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":605
 *             last = intBitSetGetNext(self.bitset, -1)
 *             for i from 0 <= i < index:
 *                 last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<< 
 *         else:
 *             raise IndexError, "intbitset index out of range"
 */
      __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_last);
    }
    goto __pyx_L4;
  }
  /*else*/ {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":607
 *                 last = intBitSetGetNext(self.bitset, last)
 *         else:
 *             raise IndexError, "intbitset index out of range"             # <<<<<<<<<<<<<< 
 *         return last
 * 
 */
    __Pyx_Raise(__pyx_builtin_IndexError, __pyx_k80p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 607; goto __pyx_L1;}
  }
  __pyx_L4:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":608
 *         else:
 *             raise IndexError, "intbitset index out of range"
 *         return last             # <<<<<<<<<<<<<< 
 * 
 *     def to_sorted_list(self, int i, int j):
 */
  __pyx_3 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 608; goto __pyx_L1;}
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.get_sorted_element");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k81p;
static PyObject *__pyx_k82p;

static char (__pyx_k81[]) = "It's impossible to retrieve a sublist using negative indices from an infinite set.";
static char (__pyx_k82[]) = "Indexes must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset_to_sorted_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_to_sorted_list[] = "Return a sublist of the sorted representation of the set.\n        Note, negative indices are not supported.";
static PyObject *__pyx_f_py_9intbitset_9intbitset_to_sorted_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_i;
  int __pyx_v_j;
  int __pyx_v_l;
  int __pyx_v_last;
  int __pyx_v_cnt;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  static char *__pyx_argnames[] = {"i","j",0};
  if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "ii", __pyx_argnames, &__pyx_v_i, &__pyx_v_j))) return 0;
  Py_INCREF(__pyx_v_self);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":616
 *         cdef int last
 *         cdef int cnt
 *         if self.bitset.trailing_bits and (i < 0 or j < 0):             # <<<<<<<<<<<<<< 
 *             raise OverflowError, "It's impossible to retrieve a sublist using negative indices from an infinite set."
 *         elif (i > maxelem or j > maxelem):
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_i < 0);
    if (!__pyx_1) {
      __pyx_1 = (__pyx_v_j < 0);
    }
  }
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":617
 *         cdef int cnt
 *         if self.bitset.trailing_bits and (i < 0 or j < 0):
 *             raise OverflowError, "It's impossible to retrieve a sublist using negative indices from an infinite set."             # <<<<<<<<<<<<<< 
 *         elif (i > maxelem or j > maxelem):
 *             raise OverflowError, "Indexes must be <= %s" % maxelem
 */
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_k81p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 617; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_1 = (__pyx_v_i > maxelem);
  if (!__pyx_1) {
    __pyx_1 = (__pyx_v_j > maxelem);
  }
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":619
 *             raise OverflowError, "It's impossible to retrieve a sublist using negative indices from an infinite set."
 *         elif (i > maxelem or j > maxelem):
 *             raise OverflowError, "Indexes must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         l = intBitSetGetTot(self.bitset)
 *         if i == 0 and j == -1:
 */
    __pyx_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 619; goto __pyx_L1;}
    __pyx_3 = PyNumber_Remainder(__pyx_k82p, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 619; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_3, 0);
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 619; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":620
 *         elif (i > maxelem or j > maxelem):
 *             raise OverflowError, "Indexes must be <= %s" % maxelem
 *         l = intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<< 
 *         if i == 0 and j == -1:
 *             return intbitset(self)
 */
  __pyx_v_l = intBitSetGetTot(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":621
 *             raise OverflowError, "Indexes must be <= %s" % maxelem
 *         l = intBitSetGetTot(self.bitset)
 *         if i == 0 and j == -1:             # <<<<<<<<<<<<<< 
 *             return intbitset(self)
 *         ret = intbitset()
 */
  __pyx_1 = (__pyx_v_i == 0);
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_j == -1);
  }
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":622
 *         l = intBitSetGetTot(self.bitset)
 *         if i == 0 and j == -1:
 *             return intbitset(self)             # <<<<<<<<<<<<<< 
 *         ret = intbitset()
 *         if i < 0:
 */
    __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; goto __pyx_L1;}
    Py_INCREF(__pyx_v_self);
    PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_self);
    __pyx_3 = PyObject_CallObject(((PyObject*)__pyx_ptype_9intbitset_intbitset), __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __pyx_r = __pyx_3;
    __pyx_3 = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":623
 *         if i == 0 and j == -1:
 *             return intbitset(self)
 *         ret = intbitset()             # <<<<<<<<<<<<<< 
 *         if i < 0:
 *             i = i + l
 */
  __pyx_2 = PyObject_CallObject(((PyObject*)__pyx_ptype_9intbitset_intbitset), 0); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 623; goto __pyx_L1;}
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_2;
  __pyx_2 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":624
 *             return intbitset(self)
 *         ret = intbitset()
 *         if i < 0:             # <<<<<<<<<<<<<< 
 *             i = i + l
 *         if j < 0:
 */
  __pyx_1 = (__pyx_v_i < 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":625
 *         ret = intbitset()
 *         if i < 0:
 *             i = i + l             # <<<<<<<<<<<<<< 
 *         if j < 0:
 *             j = j + l
 */
    __pyx_v_i = (__pyx_v_i + __pyx_v_l);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":626
 *         if i < 0:
 *             i = i + l
 *         if j < 0:             # <<<<<<<<<<<<<< 
 *             j = j + l
 *         if i >= l:
 */
  __pyx_1 = (__pyx_v_j < 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":627
 *             i = i + l
 *         if j < 0:
 *             j = j + l             # <<<<<<<<<<<<<< 
 *         if i >= l:
 *             i = l
 */
    __pyx_v_j = (__pyx_v_j + __pyx_v_l);
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":628
 *         if j < 0:
 *             j = j + l
 *         if i >= l:             # <<<<<<<<<<<<<< 
 *             i = l
 *         if j >= l:
 */
  __pyx_1 = (__pyx_v_i >= __pyx_v_l);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":629
 *             j = j + l
 *         if i >= l:
 *             i = l             # <<<<<<<<<<<<<< 
 *         if j >= l:
 *             j = l
 */
    __pyx_v_i = __pyx_v_l;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":630
 *         if i >= l:
 *             i = l
 *         if j >= l:             # <<<<<<<<<<<<<< 
 *             j = l
 *         last = -1
 */
  __pyx_1 = (__pyx_v_j >= __pyx_v_l);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":631
 *             i = l
 *         if j >= l:
 *             j = l             # <<<<<<<<<<<<<< 
 *         last = -1
 *         for cnt from 0 <= cnt < i:
 */
    __pyx_v_j = __pyx_v_l;
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":632
 *         if j >= l:
 *             j = l
 *         last = -1             # <<<<<<<<<<<<<< 
 *         for cnt from 0 <= cnt < i:
 *             last = intBitSetGetNext(self.bitset, last)
 */
  __pyx_v_last = -1;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":633
 *             j = l
 *         last = -1
 *         for cnt from 0 <= cnt < i:             # <<<<<<<<<<<<<< 
 *             last = intBitSetGetNext(self.bitset, last)
 *         for cnt from i <= cnt < j:
 */
  for (__pyx_v_cnt = 0; __pyx_v_cnt < __pyx_v_i; __pyx_v_cnt++) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":634
 *         last = -1
 *         for cnt from 0 <= cnt < i:
 *             last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<< 
 *         for cnt from i <= cnt < j:
 *             last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_last);
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":635
 *         for cnt from 0 <= cnt < i:
 *             last = intBitSetGetNext(self.bitset, last)
 *         for cnt from i <= cnt < j:             # <<<<<<<<<<<<<< 
 *             last = intBitSetGetNext(self.bitset, last)
 *             intBitSetAddElem((<intbitset> ret).bitset, last)
 */
  for (__pyx_v_cnt = __pyx_v_i; __pyx_v_cnt < __pyx_v_j; __pyx_v_cnt++) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":636
 *             last = intBitSetGetNext(self.bitset, last)
 *         for cnt from i <= cnt < j:
 *             last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<< 
 *             intBitSetAddElem((<intbitset> ret).bitset, last)
 *         return ret
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_last);

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":637
 *         for cnt from i <= cnt < j:
 *             last = intBitSetGetNext(self.bitset, last)
 *             intBitSetAddElem((<intbitset> ret).bitset, last)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
    intBitSetAddElem(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_ret)->bitset,__pyx_v_last);
  }

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":638
 *             last = intBitSetGetNext(self.bitset, last)
 *             intBitSetAddElem((<intbitset> ret).bitset, last)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def is_infinite(self):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.to_sorted_list");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_is_infinite(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_is_infinite[] = "Return True if the intbitset is infinite. (i.e. trailing_bits=True\n        was used in the constructor.)";
static PyObject *__pyx_f_py_9intbitset_9intbitset_is_infinite(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":643
 *         """Return True if the intbitset is infinite. (i.e. trailing_bits=True
 *         was used in the constructor.)"""
 *         return self.bitset.trailing_bits != 0             # <<<<<<<<<<<<<< 
 * 
 *     def extract_finite_list(self, int up_to=-1):
 */
  __pyx_1 = __Pyx_PyBool_FromLong((((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits != 0)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 643; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("intbitset.intbitset.is_infinite");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_n_append;

static PyObject *__pyx_k83p;

static char (__pyx_k83[]) = "up_to must be <= %s";

static PyObject *__pyx_f_py_9intbitset_9intbitset_extract_finite_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_extract_finite_list[] = "Return a finite list of elements sufficient to be passed to intbitset\n        constructor toghether with the proper value of trailing_bits in order\n        to reproduce this intbitset. At least up_to integer are looked for when\n        they are inside the intbitset but not necessarily needed to build the\n        intbitset";
static PyObject *__pyx_f_py_9intbitset_9intbitset_extract_finite_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_up_to;
  int __pyx_v_true_up_to;
  int __pyx_v_last;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  static char *__pyx_argnames[] = {"up_to",0};
  __pyx_v_up_to = __pyx_k13;
  if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "|i", __pyx_argnames, &__pyx_v_up_to))) return 0;
  Py_INCREF(__pyx_v_self);
  __pyx_v_ret = Py_None; Py_INCREF(Py_None);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":653
 *         cdef int true_up_to
 *         cdef int last
 *         if self.sanity_checks and up_to > maxelem:             # <<<<<<<<<<<<<< 
 *             raise OverflowError, "up_to must be <= %s" % maxelem
 *         ret = []
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_up_to > maxelem);
  }
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":654
 *         cdef int last
 *         if self.sanity_checks and up_to > maxelem:
 *             raise OverflowError, "up_to must be <= %s" % maxelem             # <<<<<<<<<<<<<< 
 *         ret = []
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 */
    __pyx_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 654; goto __pyx_L1;}
    __pyx_3 = PyNumber_Remainder(__pyx_k83p, __pyx_2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 654; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_3, 0);
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 654; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":655
 *         if self.sanity_checks and up_to > maxelem:
 *             raise OverflowError, "up_to must be <= %s" % maxelem
 *         ret = []             # <<<<<<<<<<<<<< 
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 *         last = -1
 */
  __pyx_2 = PyList_New(0); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 655; goto __pyx_L1;}
  Py_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_2;
  __pyx_2 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":656
 *             raise OverflowError, "up_to must be <= %s" % maxelem
 *         ret = []
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)             # <<<<<<<<<<<<<< 
 *         last = -1
 *         while last < true_up_to:
 */
  __pyx_3 = PyInt_FromLong(__pyx_v_up_to); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 656; goto __pyx_L1;}
  __pyx_2 = PyInt_FromLong((intBitSetGetSize(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset) * wordbitsize)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 656; goto __pyx_L1;}
  __pyx_4 = PyTuple_New(2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 656; goto __pyx_L1;}
  PyTuple_SET_ITEM(__pyx_4, 0, __pyx_3);
  PyTuple_SET_ITEM(__pyx_4, 1, __pyx_2);
  __pyx_3 = 0;
  __pyx_2 = 0;
  __pyx_3 = PyObject_CallObject(__pyx_builtin_max, __pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 656; goto __pyx_L1;}
  Py_DECREF(__pyx_4); __pyx_4 = 0;
  __pyx_5 = PyInt_AsLong(__pyx_3); if (unlikely((__pyx_5 == -1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 656; goto __pyx_L1;}
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  __pyx_v_true_up_to = __pyx_5;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":657
 *         ret = []
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 *         last = -1             # <<<<<<<<<<<<<< 
 *         while last < true_up_to:
 *             last = intBitSetGetNext(self.bitset, last)
 */
  __pyx_v_last = -1;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":658
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 *         last = -1
 *         while last < true_up_to:             # <<<<<<<<<<<<<< 
 *             last = intBitSetGetNext(self.bitset, last)
 *             if last == -2:
 */
  while (1) {
    __pyx_1 = (__pyx_v_last < __pyx_v_true_up_to);
    if (!__pyx_1) break;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":659
 *         last = -1
 *         while last < true_up_to:
 *             last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<< 
 *             if last == -2:
 *                 break
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset,__pyx_v_last);

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":660
 *         while last < true_up_to:
 *             last = intBitSetGetNext(self.bitset, last)
 *             if last == -2:             # <<<<<<<<<<<<<< 
 *                 break
 *             ret.append(last)
 */
    __pyx_1 = (__pyx_v_last == -2);
    if (__pyx_1) {

      /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":661
 *             last = intBitSetGetNext(self.bitset, last)
 *             if last == -2:
 *                 break             # <<<<<<<<<<<<<< 
 *             ret.append(last)
 *         return ret
 */
      goto __pyx_L4;
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":662
 *             if last == -2:
 *                 break
 *             ret.append(last)             # <<<<<<<<<<<<<< 
 *         return ret
 * 
 */
    __pyx_2 = PyObject_GetAttr(__pyx_v_ret, __pyx_n_append); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 662; goto __pyx_L1;}
    __pyx_4 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 662; goto __pyx_L1;}
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 662; goto __pyx_L1;}
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_4);
    __pyx_4 = 0;
    __pyx_4 = PyObject_CallObject(__pyx_2, __pyx_3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 662; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    Py_DECREF(__pyx_4); __pyx_4 = 0;
  }
  __pyx_L4:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":663
 *                 break
 *             ret.append(last)
 *         return ret             # <<<<<<<<<<<<<< 
 * 
 *     def get_wordbitsize(self):
 */
  Py_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("intbitset.intbitset.extract_finite_list");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_ret);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_get_wordbitsize(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset_get_wordbitsize(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":666
 * 
 *     def get_wordbitsize(self):
 *         return wordbitsize             # <<<<<<<<<<<<<< 
 * 
 *     def get_wordbytsize(self):
 */
  __pyx_1 = PyInt_FromLong(wordbitsize); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 666; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("intbitset.intbitset.get_wordbitsize");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_9intbitset_get_wordbytsize(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_f_py_9intbitset_9intbitset_get_wordbytsize(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":669
 * 
 *     def get_wordbytsize(self):
 *         return wordbytesize             # <<<<<<<<<<<<<< 
 * 
 *     def tolist(self):
 */
  __pyx_1 = PyInt_FromLong(wordbytesize); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("intbitset.intbitset.get_wordbytsize");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_k84p;

static char (__pyx_k84[]) = "It's impossible to retrieve a list of an infinite set";

static PyObject *__pyx_f_py_9intbitset_9intbitset_tolist(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_9intbitset_9intbitset_tolist[] = "Legacy method to retrieve a list of all the elements inside an\n        intbitset.\n        ";
static PyObject *__pyx_f_py_9intbitset_9intbitset_tolist(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r;
  word_t __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":675
 *         intbitset.
 *         """
 *         if self.bitset.trailing_bits:             # <<<<<<<<<<<<<< 
 *             raise OverflowError, "It's impossible to retrieve a list of an infinite set"
 *         return self.extract_finite_list()
 */
  __pyx_1 = ((struct __pyx_obj_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":676
 *         """
 *         if self.bitset.trailing_bits:
 *             raise OverflowError, "It's impossible to retrieve a list of an infinite set"             # <<<<<<<<<<<<<< 
 *         return self.extract_finite_list()
 * 
 */
    __Pyx_Raise(__pyx_builtin_OverflowError, __pyx_k84p, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":677
 *         if self.bitset.trailing_bits:
 *             raise OverflowError, "It's impossible to retrieve a list of an infinite set"
 *         return self.extract_finite_list()             # <<<<<<<<<<<<<< 
 * 
 * cdef class intbitset_iterator:
 */
  __pyx_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_extract_finite_list); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 677; goto __pyx_L1;}
  __pyx_3 = PyObject_CallObject(__pyx_2, 0); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 677; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("intbitset.intbitset.tolist");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static int __pyx_f_py_9intbitset_18intbitset_iterator___new__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_f_py_9intbitset_18intbitset_iterator___new__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_9intbitset_intbitset *__pyx_v_bitset = 0;
  int __pyx_r;
  static char *__pyx_argnames[] = {"bitset",0};
  if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O", __pyx_argnames, &__pyx_v_bitset))) return -1;
  Py_INCREF(__pyx_v_self);
  Py_INCREF(__pyx_v_bitset);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_bitset), __pyx_ptype_9intbitset_intbitset, 0, "bitset"))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 683; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":684
 * 
 *     def __new__(self, intbitset bitset not None):
 *         self.last = -1             # <<<<<<<<<<<<<< 
 *         self.bitset = bitset.bitset
 * 
 */
  ((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->last = -1;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":685
 *     def __new__(self, intbitset bitset not None):
 *         self.last = -1
 *         self.bitset = bitset.bitset             # <<<<<<<<<<<<<< 
 * 
 *     def __next__(self):
 */
  ((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset = __pyx_v_bitset->bitset;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("intbitset.intbitset_iterator.__new__");
  __pyx_r = -1;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  Py_DECREF(__pyx_v_bitset);
  return __pyx_r;
}

static PyObject *__pyx_n_StopIteration;

static PyObject *__pyx_builtin_StopIteration;

static PyObject *__pyx_f_py_9intbitset_18intbitset_iterator___next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_f_py_9intbitset_18intbitset_iterator___next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":688
 * 
 *     def __next__(self):
 *         self.last = intBitSetGetNext((<intbitset_iterator>self).bitset, self.last)             # <<<<<<<<<<<<<< 
 *         if self.last < 0:
 *             self.last = -2
 */
  ((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->last = intBitSetGetNext(((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset,((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->last);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":689
 *     def __next__(self):
 *         self.last = intBitSetGetNext((<intbitset_iterator>self).bitset, self.last)
 *         if self.last < 0:             # <<<<<<<<<<<<<< 
 *             self.last = -2
 *             raise StopIteration
 */
  __pyx_1 = (((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->last < 0);
  if (__pyx_1) {

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":690
 *         self.last = intBitSetGetNext((<intbitset_iterator>self).bitset, self.last)
 *         if self.last < 0:
 *             self.last = -2             # <<<<<<<<<<<<<< 
 *             raise StopIteration
 *         return self.last
 */
    ((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->last = -2;

    /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":691
 *         if self.last < 0:
 *             self.last = -2
 *             raise StopIteration             # <<<<<<<<<<<<<< 
 *         return self.last
 * 
 */
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; goto __pyx_L1;}
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":692
 *             self.last = -2
 *             raise StopIteration
 *         return self.last             # <<<<<<<<<<<<<< 
 * 
 *     def __iter__(self):
 */
  __pyx_2 = PyInt_FromLong(((struct __pyx_obj_9intbitset_intbitset_iterator *)__pyx_v_self)->last); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 692; goto __pyx_L1;}
  __pyx_r = __pyx_2;
  __pyx_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("intbitset.intbitset_iterator.__next__");
  __pyx_r = 0;
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static PyObject *__pyx_f_py_9intbitset_18intbitset_iterator___iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_f_py_9intbitset_18intbitset_iterator___iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  Py_INCREF(__pyx_v_self);

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":695
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<< 
 */
  Py_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  __pyx_L0:;
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}

static __Pyx_InternTabEntry __pyx_intern_tab[] = {
  {&__pyx_n_AttributeError, "AttributeError"},
  {&__pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS, "CFG_INTBITSET_ENABLE_SANITY_CHECKS"},
  {&__pyx_n_Error, "Error"},
  {&__pyx_n_Exception, "Exception"},
  {&__pyx_n_IndexError, "IndexError"},
  {&__pyx_n_KeyError, "KeyError"},
  {&__pyx_n_OverflowError, "OverflowError"},
  {&__pyx_n_StopIteration, "StopIteration"},
  {&__pyx_n_TypeError, "TypeError"},
  {&__pyx_n_ValueError, "ValueError"},
  {&__pyx_n___and__, "__and__"},
  {&__pyx_n___apilevel__, "__apilevel__"},
  {&__pyx_n___cmp__, "__cmp__"},
  {&__pyx_n___contains__, "__contains__"},
  {&__pyx_n___dealloc__, "__dealloc__"},
  {&__pyx_n___deepcopy__, "__deepcopy__"},
  {&__pyx_n___del__, "__del__"},
  {&__pyx_n___ge__, "__ge__"},
  {&__pyx_n___hash__, "__hash__"},
  {&__pyx_n___iadd__, "__iadd__"},
  {&__pyx_n___iand__, "__iand__"},
  {&__pyx_n___ior__, "__ior__"},
  {&__pyx_n___isub__, "__isub__"},
  {&__pyx_n___iter__, "__iter__"},
  {&__pyx_n___ixor__, "__ixor__"},
  {&__pyx_n___le__, "__le__"},
  {&__pyx_n___len__, "__len__"},
  {&__pyx_n___maxelem__, "__maxelem__"},
  {&__pyx_n___new__, "__new__"},
  {&__pyx_n___next__, "__next__"},
  {&__pyx_n___nonzero__, "__nonzero__"},
  {&__pyx_n___or__, "__or__"},
  {&__pyx_n___repr__, "__repr__"},
  {&__pyx_n___revision__, "__revision__"},
  {&__pyx_n___richcmp__, "__richcmp__"},
  {&__pyx_n___str__, "__str__"},
  {&__pyx_n___sub__, "__sub__"},
  {&__pyx_n___xor__, "__xor__"},
  {&__pyx_n_add, "add"},
  {&__pyx_n_append, "append"},
  {&__pyx_n_array, "array"},
  {&__pyx_n_clear, "clear"},
  {&__pyx_n_compress, "compress"},
  {&__pyx_n_copy, "copy"},
  {&__pyx_n_decompress, "decompress"},
  {&__pyx_n_difference, "difference"},
  {&__pyx_n_difference_update, "difference_update"},
  {&__pyx_n_discard, "discard"},
  {&__pyx_n_endswith, "endswith"},
  {&__pyx_n_extract_finite_list, "extract_finite_list"},
  {&__pyx_n_fastdump, "fastdump"},
  {&__pyx_n_fastload, "fastload"},
  {&__pyx_n_get_allocated, "get_allocated"},
  {&__pyx_n_get_size, "get_size"},
  {&__pyx_n_get_sorted_element, "get_sorted_element"},
  {&__pyx_n_get_wordbitsize, "get_wordbitsize"},
  {&__pyx_n_get_wordbytsize, "get_wordbytsize"},
  {&__pyx_n_intersection, "intersection"},
  {&__pyx_n_intersection_update, "intersection_update"},
  {&__pyx_n_is_infinite, "is_infinite"},
  {&__pyx_n_issubset, "issubset"},
  {&__pyx_n_issuperset, "issuperset"},
  {&__pyx_n_iteritems, "iteritems"},
  {&__pyx_n_max, "max"},
  {&__pyx_n_no_allocate, "no_allocate"},
  {&__pyx_n_pop, "pop"},
  {&__pyx_n_remove, "remove"},
  {&__pyx_n_strbits, "strbits"},
  {&__pyx_n_symmetric_difference, "symmetric_difference"},
  {&__pyx_n_symmetric_difference_update, "symmetric_difference_update"},
  {&__pyx_n_to_sorted_list, "to_sorted_list"},
  {&__pyx_n_tolist, "tolist"},
  {&__pyx_n_tostring, "tostring"},
  {&__pyx_n_union, "union"},
  {&__pyx_n_union_update, "union_update"},
  {&__pyx_n_update_with_signs, "update_with_signs"},
  {&__pyx_n_zlib, "zlib"},
  {0, 0}
};

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_k1p, __pyx_k1, sizeof(__pyx_k1), 0},
  {&__pyx_k6p, __pyx_k6, sizeof(__pyx_k6), 0},
  {&__pyx_k15p, __pyx_k15, sizeof(__pyx_k15), 0},
  {&__pyx_k16p, __pyx_k16, sizeof(__pyx_k16), 0},
  {&__pyx_k17p, __pyx_k17, sizeof(__pyx_k17), 0},
  {&__pyx_k19p, __pyx_k19, sizeof(__pyx_k19), 0},
  {&__pyx_k20p, __pyx_k20, sizeof(__pyx_k20), 0},
  {&__pyx_k21p, __pyx_k21, sizeof(__pyx_k21), 0},
  {&__pyx_k22p, __pyx_k22, sizeof(__pyx_k22), 0},
  {&__pyx_k23p, __pyx_k23, sizeof(__pyx_k23), 0},
  {&__pyx_k24p, __pyx_k24, sizeof(__pyx_k24), 0},
  {&__pyx_k25p, __pyx_k25, sizeof(__pyx_k25), 0},
  {&__pyx_k26p, __pyx_k26, sizeof(__pyx_k26), 0},
  {&__pyx_k27p, __pyx_k27, sizeof(__pyx_k27), 0},
  {&__pyx_k28p, __pyx_k28, sizeof(__pyx_k28), 0},
  {&__pyx_k29p, __pyx_k29, sizeof(__pyx_k29), 0},
  {&__pyx_k30p, __pyx_k30, sizeof(__pyx_k30), 0},
  {&__pyx_k31p, __pyx_k31, sizeof(__pyx_k31), 0},
  {&__pyx_k32p, __pyx_k32, sizeof(__pyx_k32), 0},
  {&__pyx_k33p, __pyx_k33, sizeof(__pyx_k33), 0},
  {&__pyx_k34p, __pyx_k34, sizeof(__pyx_k34), 0},
  {&__pyx_k35p, __pyx_k35, sizeof(__pyx_k35), 0},
  {&__pyx_k36p, __pyx_k36, sizeof(__pyx_k36), 0},
  {&__pyx_k37p, __pyx_k37, sizeof(__pyx_k37), 0},
  {&__pyx_k38p, __pyx_k38, sizeof(__pyx_k38), 0},
  {&__pyx_k39p, __pyx_k39, sizeof(__pyx_k39), 0},
  {&__pyx_k40p, __pyx_k40, sizeof(__pyx_k40), 0},
  {&__pyx_k45p, __pyx_k45, sizeof(__pyx_k45), 0},
  {&__pyx_k46p, __pyx_k46, sizeof(__pyx_k46), 0},
  {&__pyx_k47p, __pyx_k47, sizeof(__pyx_k47), 0},
  {&__pyx_k48p, __pyx_k48, sizeof(__pyx_k48), 0},
  {&__pyx_k49p, __pyx_k49, sizeof(__pyx_k49), 0},
  {&__pyx_k50p, __pyx_k50, sizeof(__pyx_k50), 0},
  {&__pyx_k51p, __pyx_k51, sizeof(__pyx_k51), 0},
  {&__pyx_k52p, __pyx_k52, sizeof(__pyx_k52), 0},
  {&__pyx_k53p, __pyx_k53, sizeof(__pyx_k53), 0},
  {&__pyx_k54p, __pyx_k54, sizeof(__pyx_k54), 0},
  {&__pyx_k55p, __pyx_k55, sizeof(__pyx_k55), 0},
  {&__pyx_k56p, __pyx_k56, sizeof(__pyx_k56), 0},
  {&__pyx_k57p, __pyx_k57, sizeof(__pyx_k57), 0},
  {&__pyx_k58p, __pyx_k58, sizeof(__pyx_k58), 0},
  {&__pyx_k59p, __pyx_k59, sizeof(__pyx_k59), 0},
  {&__pyx_k60p, __pyx_k60, sizeof(__pyx_k60), 0},
  {&__pyx_k61p, __pyx_k61, sizeof(__pyx_k61), 0},
  {&__pyx_k62p, __pyx_k62, sizeof(__pyx_k62), 0},
  {&__pyx_k63p, __pyx_k63, sizeof(__pyx_k63), 0},
  {&__pyx_k64p, __pyx_k64, sizeof(__pyx_k64), 0},
  {&__pyx_k65p, __pyx_k65, sizeof(__pyx_k65), 0},
  {&__pyx_k66p, __pyx_k66, sizeof(__pyx_k66), 0},
  {&__pyx_k67p, __pyx_k67, sizeof(__pyx_k67), 0},
  {&__pyx_k68p, __pyx_k68, sizeof(__pyx_k68), 0},
  {&__pyx_k69p, __pyx_k69, sizeof(__pyx_k69), 0},
  {&__pyx_k70p, __pyx_k70, sizeof(__pyx_k70), 0},
  {&__pyx_k71p, __pyx_k71, sizeof(__pyx_k71), 0},
  {&__pyx_k72p, __pyx_k72, sizeof(__pyx_k72), 0},
  {&__pyx_k73p, __pyx_k73, sizeof(__pyx_k73), 0},
  {&__pyx_k74p, __pyx_k74, sizeof(__pyx_k74), 0},
  {&__pyx_k75p, __pyx_k75, sizeof(__pyx_k75), 0},
  {&__pyx_k76p, __pyx_k76, sizeof(__pyx_k76), 0},
  {&__pyx_k77p, __pyx_k77, sizeof(__pyx_k77), 0},
  {&__pyx_k78p, __pyx_k78, sizeof(__pyx_k78), 0},
  {&__pyx_k79p, __pyx_k79, sizeof(__pyx_k79), 0},
  {&__pyx_k80p, __pyx_k80, sizeof(__pyx_k80), 0},
  {&__pyx_k81p, __pyx_k81, sizeof(__pyx_k81), 0},
  {&__pyx_k82p, __pyx_k82, sizeof(__pyx_k82), 0},
  {&__pyx_k83p, __pyx_k83, sizeof(__pyx_k83), 0},
  {&__pyx_k84p, __pyx_k84, sizeof(__pyx_k84), 0},
  {0, 0, 0, 0}
};

static PyObject *__pyx_tp_new_9intbitset_intbitset(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (__pyx_f_py_9intbitset_9intbitset___new__(o, a, k) < 0) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9intbitset_intbitset(PyObject *o) {
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++o->ob_refcnt;
    __pyx_f_py_9intbitset_9intbitset___dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --o->ob_refcnt;
    PyErr_Restore(etype, eval, etb);
  }
  (*o->ob_type->tp_free)(o);
}

static int __pyx_tp_traverse_9intbitset_intbitset(PyObject *o, visitproc v, void *a) {
  return 0;
}

static int __pyx_tp_clear_9intbitset_intbitset(PyObject *o) {
  return 0;
}

static struct PyMethodDef __pyx_methods_9intbitset_intbitset[] = {
  {"__iadd__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___iadd__, METH_O|METH_COEXIST, 0},
  {"__isub__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___isub__, METH_O|METH_COEXIST, 0},
  {"__deepcopy__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___deepcopy__, METH_O, 0},
  {"__del__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___del__, METH_O, 0},
  {"__and__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___and__, METH_O|METH_COEXIST, 0},
  {"__or__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___or__, METH_O|METH_COEXIST, 0},
  {"__xor__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___xor__, METH_O|METH_COEXIST, 0},
  {"__sub__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___sub__, METH_O|METH_COEXIST, 0},
  {"__iand__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___iand__, METH_O|METH_COEXIST, 0},
  {"__ior__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___ior__, METH_O|METH_COEXIST, 0},
  {"__ixor__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___ixor__, METH_O|METH_COEXIST, 0},
  {"__repr__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___repr__, METH_NOARGS|METH_COEXIST, 0},
  {"__str__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___str__, METH_NOARGS|METH_COEXIST, 0},
  {"__iter__", (PyCFunction)__pyx_f_py_9intbitset_9intbitset___iter__, METH_NOARGS|METH_COEXIST, 0},
  {"add", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_add, METH_O, __pyx_doc_9intbitset_9intbitset_add},
  {"clear", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_clear, METH_NOARGS, 0},
  {"difference", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_difference, METH_O, __pyx_doc_9intbitset_9intbitset_difference},
  {"difference_update", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_difference_update, METH_O, __pyx_doc_9intbitset_9intbitset_difference_update},
  {"discard", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_discard, METH_O, __pyx_doc_9intbitset_9intbitset_discard},
  {"intersection", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_intersection, METH_O, __pyx_doc_9intbitset_9intbitset_intersection},
  {"intersection_update", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_intersection_update, METH_O, __pyx_doc_9intbitset_9intbitset_intersection_update},
  {"union", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_union, METH_O, __pyx_doc_9intbitset_9intbitset_union},
  {"union_update", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_union_update, METH_O, __pyx_doc_9intbitset_9intbitset_union_update},
  {"issubset", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_issubset, METH_O, __pyx_doc_9intbitset_9intbitset_issubset},
  {"issuperset", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_issuperset, METH_O, __pyx_doc_9intbitset_9intbitset_issuperset},
  {"symmetric_difference", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_symmetric_difference, METH_O, __pyx_doc_9intbitset_9intbitset_symmetric_difference},
  {"symmetric_difference_update", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_symmetric_difference_update, METH_O, __pyx_doc_9intbitset_9intbitset_symmetric_difference_update},
  {"fastdump", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_fastdump, METH_NOARGS, __pyx_doc_9intbitset_9intbitset_fastdump},
  {"fastload", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_fastload, METH_O, __pyx_doc_9intbitset_9intbitset_fastload},
  {"copy", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_copy, METH_NOARGS, __pyx_doc_9intbitset_9intbitset_copy},
  {"pop", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_pop, METH_NOARGS, __pyx_doc_9intbitset_9intbitset_pop},
  {"remove", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_remove, METH_O, __pyx_doc_9intbitset_9intbitset_remove},
  {"strbits", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_strbits, METH_NOARGS, __pyx_doc_9intbitset_9intbitset_strbits},
  {"update_with_signs", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_update_with_signs, METH_O, __pyx_doc_9intbitset_9intbitset_update_with_signs},
  {"get_size", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_get_size, METH_NOARGS, 0},
  {"get_allocated", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_get_allocated, METH_NOARGS, 0},
  {"get_sorted_element", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_get_sorted_element, METH_O, __pyx_doc_9intbitset_9intbitset_get_sorted_element},
  {"to_sorted_list", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_to_sorted_list, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9intbitset_9intbitset_to_sorted_list},
  {"is_infinite", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_is_infinite, METH_NOARGS, __pyx_doc_9intbitset_9intbitset_is_infinite},
  {"extract_finite_list", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_extract_finite_list, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9intbitset_9intbitset_extract_finite_list},
  {"get_wordbitsize", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_get_wordbitsize, METH_NOARGS, 0},
  {"get_wordbytsize", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_get_wordbytsize, METH_NOARGS, 0},
  {"tolist", (PyCFunction)__pyx_f_py_9intbitset_9intbitset_tolist, METH_NOARGS, __pyx_doc_9intbitset_9intbitset_tolist},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_intbitset = {
  0, /*nb_add*/
  __pyx_f_py_9intbitset_9intbitset___sub__, /*nb_subtract*/
  0, /*nb_multiply*/
  0, /*nb_divide*/
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  __pyx_f_py_9intbitset_9intbitset___nonzero__, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  __pyx_f_py_9intbitset_9intbitset___and__, /*nb_and*/
  __pyx_f_py_9intbitset_9intbitset___xor__, /*nb_xor*/
  __pyx_f_py_9intbitset_9intbitset___or__, /*nb_or*/
  0, /*nb_coerce*/
  0, /*nb_int*/
  0, /*nb_long*/
  0, /*nb_float*/
  0, /*nb_oct*/
  0, /*nb_hex*/
  __pyx_f_py_9intbitset_9intbitset___iadd__, /*nb_inplace_add*/
  __pyx_f_py_9intbitset_9intbitset___isub__, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  0, /*nb_inplace_divide*/
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  __pyx_f_py_9intbitset_9intbitset___iand__, /*nb_inplace_and*/
  __pyx_f_py_9intbitset_9intbitset___ixor__, /*nb_inplace_xor*/
  __pyx_f_py_9intbitset_9intbitset___ior__, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_intbitset = {
  __pyx_f_py_9intbitset_9intbitset___len__, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  __pyx_f_py_9intbitset_9intbitset___contains__, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_intbitset = {
  __pyx_f_py_9intbitset_9intbitset___len__, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_intbitset = {
  0, /*bf_getreadbuffer*/
  0, /*bf_getwritebuffer*/
  0, /*bf_getsegcount*/
  0, /*bf_getcharbuffer*/
};

PyTypeObject __pyx_type_9intbitset_intbitset = {
  PyObject_HEAD_INIT(0)
  0, /*ob_size*/
  "intbitset.intbitset", /*tp_name*/
  sizeof(struct __pyx_obj_9intbitset_intbitset), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9intbitset_intbitset, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  __pyx_f_py_9intbitset_9intbitset___cmp__, /*tp_compare*/
  __pyx_f_py_9intbitset_9intbitset___repr__, /*tp_repr*/
  &__pyx_tp_as_number_intbitset, /*tp_as_number*/
  &__pyx_tp_as_sequence_intbitset, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_intbitset, /*tp_as_mapping*/
  __pyx_f_py_9intbitset_9intbitset___hash__, /*tp_hash*/
  0, /*tp_call*/
  __pyx_f_py_9intbitset_9intbitset___str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_intbitset, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Defines an intbitset data object to hold unordered sets of\n    unsigned integers with ultra fast set operations, implemented via\n    bit vectors and Python C extension to optimize speed and memory\n    usage.\n\n    Emulates the Python built-in set class interface with some\n    additional specific methods such as its own fast dump and load\n    marshalling functions.  Uses real bits to optimize memory usage,\n    so may have issues with endianness if you transport serialized\n    bitsets between various machine architectures.\n\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_9intbitset_intbitset, /*tp_traverse*/
  __pyx_tp_clear_9intbitset_intbitset, /*tp_clear*/
  __pyx_f_py_9intbitset_9intbitset___richcmp__, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_f_py_9intbitset_9intbitset___iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9intbitset_intbitset, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9intbitset_intbitset, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static PyObject *__pyx_tp_new_9intbitset_intbitset_iterator(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (__pyx_f_py_9intbitset_18intbitset_iterator___new__(o, a, k) < 0) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9intbitset_intbitset_iterator(PyObject *o) {
  (*o->ob_type->tp_free)(o);
}

static int __pyx_tp_traverse_9intbitset_intbitset_iterator(PyObject *o, visitproc v, void *a) {
  return 0;
}

static int __pyx_tp_clear_9intbitset_intbitset_iterator(PyObject *o) {
  return 0;
}

static struct PyMethodDef __pyx_methods_9intbitset_intbitset_iterator[] = {
  {"__next__", (PyCFunction)__pyx_f_py_9intbitset_18intbitset_iterator___next__, METH_NOARGS|METH_COEXIST, 0},
  {"__iter__", (PyCFunction)__pyx_f_py_9intbitset_18intbitset_iterator___iter__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_intbitset_iterator = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  0, /*nb_divide*/
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  0, /*nb_coerce*/
  0, /*nb_int*/
  0, /*nb_long*/
  0, /*nb_float*/
  0, /*nb_oct*/
  0, /*nb_hex*/
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  0, /*nb_inplace_divide*/
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_intbitset_iterator = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_intbitset_iterator = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_intbitset_iterator = {
  0, /*bf_getreadbuffer*/
  0, /*bf_getwritebuffer*/
  0, /*bf_getsegcount*/
  0, /*bf_getcharbuffer*/
};

PyTypeObject __pyx_type_9intbitset_intbitset_iterator = {
  PyObject_HEAD_INIT(0)
  0, /*ob_size*/
  "intbitset.intbitset_iterator", /*tp_name*/
  sizeof(struct __pyx_obj_9intbitset_intbitset_iterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9intbitset_intbitset_iterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  0, /*tp_compare*/
  0, /*tp_repr*/
  &__pyx_tp_as_number_intbitset_iterator, /*tp_as_number*/
  &__pyx_tp_as_sequence_intbitset_iterator, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_intbitset_iterator, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_intbitset_iterator, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9intbitset_intbitset_iterator, /*tp_traverse*/
  __pyx_tp_clear_9intbitset_intbitset_iterator, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_f_py_9intbitset_18intbitset_iterator___iter__, /*tp_iter*/
  __pyx_f_py_9intbitset_18intbitset_iterator___next__, /*tp_iternext*/
  __pyx_methods_9intbitset_intbitset_iterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9intbitset_intbitset_iterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static struct PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

static void __pyx_init_filenames(void); /*proto*/

PyMODINIT_FUNC initintbitset(void); /*proto*/
PyMODINIT_FUNC initintbitset(void) {
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  __pyx_init_filenames();
  __pyx_m = Py_InitModule4("intbitset", __pyx_methods, 0, 0, PYTHON_API_VERSION);
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_b = PyImport_AddModule("__builtin__");
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_num_0 = PyInt_FromLong(0); if (unlikely(!__pyx_num_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_num_2 = PyInt_FromLong(2); if (unlikely(!__pyx_num_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_num_1 = PyInt_FromLong(1); if (unlikely(!__pyx_num_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_num_10 = PyInt_FromLong(10); if (unlikely(!__pyx_num_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_num_5 = PyInt_FromLong(5); if (unlikely(!__pyx_num_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  if (__Pyx_InternStrings(__pyx_intern_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;};
  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_n_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; goto __pyx_L1;}
  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_n_Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; goto __pyx_L1;}
  __pyx_builtin_max = __Pyx_GetName(__pyx_b, __pyx_n_max); if (!__pyx_builtin_max) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; goto __pyx_L1;}
  __pyx_builtin_OverflowError = __Pyx_GetName(__pyx_b, __pyx_n_OverflowError); if (!__pyx_builtin_OverflowError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; goto __pyx_L1;}
  __pyx_builtin_TypeError = __Pyx_GetName(__pyx_b, __pyx_n_TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; goto __pyx_L1;}
  __pyx_builtin_KeyError = __Pyx_GetName(__pyx_b, __pyx_n_KeyError); if (!__pyx_builtin_KeyError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 526; goto __pyx_L1;}
  __pyx_builtin_AttributeError = __Pyx_GetName(__pyx_b, __pyx_n_AttributeError); if (!__pyx_builtin_AttributeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; goto __pyx_L1;}
  __pyx_builtin_IndexError = __Pyx_GetName(__pyx_b, __pyx_n_IndexError); if (!__pyx_builtin_IndexError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 607; goto __pyx_L1;}
  __pyx_builtin_StopIteration = __Pyx_GetName(__pyx_b, __pyx_n_StopIteration); if (!__pyx_builtin_StopIteration) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; goto __pyx_L1;}
  if (PyType_Ready(&__pyx_type_9intbitset_intbitset) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; goto __pyx_L1;}
  if (PyObject_SetAttrString(__pyx_m, "intbitset", (PyObject *)&__pyx_type_9intbitset_intbitset) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; goto __pyx_L1;}
  __pyx_ptype_9intbitset_intbitset = &__pyx_type_9intbitset_intbitset;
  if (PyType_Ready(&__pyx_type_9intbitset_intbitset_iterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; goto __pyx_L1;}
  if (PyObject_SetAttrString(__pyx_m, "intbitset_iterator", (PyObject *)&__pyx_type_9intbitset_intbitset_iterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; goto __pyx_L1;}
  __pyx_ptype_9intbitset_intbitset_iterator = &__pyx_type_9intbitset_intbitset_iterator;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":20
 * ## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 * 
 * __revision__ = "$Id$"             # <<<<<<<<<<<<<< 
 * __apilevel__ = 1.01
 * 
 */
  if (PyObject_SetAttr(__pyx_m, __pyx_n___revision__, __pyx_k1p) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; goto __pyx_L1;}

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":21
 * 
 * __revision__ = "$Id$"
 * __apilevel__ = 1.01             # <<<<<<<<<<<<<< 
 * 
 * """
 */
  __pyx_1 = PyFloat_FromDouble(1.01); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n___apilevel__, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":23
 * __apilevel__ = 1.01
 * 
 * """             # <<<<<<<<<<<<<< 
 * Defines an intbitset data object to hold unordered sets of unsigned
 * integers with ultra fast set operations, implemented via bit vectors
 */
  __pyx_k2;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":39
 * """
 * 
 * import zlib             # <<<<<<<<<<<<<< 
 * from array import array
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS
 */
  __pyx_1 = __Pyx_Import(__pyx_n_zlib, 0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n_zlib, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":40
 * 
 * import zlib
 * from array import array             # <<<<<<<<<<<<<< 
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS
 * 
 */
  __pyx_1 = PyList_New(1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; goto __pyx_L1;}
  Py_INCREF(__pyx_n_array);
  PyList_SET_ITEM(__pyx_1, 0, __pyx_n_array);
  __pyx_2 = __Pyx_Import(__pyx_n_array, __pyx_1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_1 = PyObject_GetAttr(__pyx_2, __pyx_n_array); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n_array, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":41
 * import zlib
 * from array import array
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS             # <<<<<<<<<<<<<< 
 * 
 * cdef extern from "intbitset.h":
 */
  __pyx_2 = PyList_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; goto __pyx_L1;}
  Py_INCREF(__pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS);
  PyList_SET_ITEM(__pyx_2, 0, __pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS);
  __pyx_1 = __Pyx_Import(__pyx_k6p, __pyx_2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_2 = PyObject_GetAttr(__pyx_1, __pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS, __pyx_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":87
 *     unsigned char intBitSetCmp(IntBitSet *x, IntBitSet *y)
 * 
 * __maxelem__ = maxelem             # <<<<<<<<<<<<<< 
 * 
 * cdef class intbitset:
 */
  __pyx_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n___maxelem__, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":107
 *     cdef bool_t sanity_checks
 * 
 *     def __new__(self, rhs=0, int preallocate=-1, int trailing_bits=0, sanity_checks=CFG_INTBITSET_ENABLE_SANITY_CHECKS, int no_allocate=0):             # <<<<<<<<<<<<<< 
 *         """
 *         Initialize intbitset.
 */
  Py_INCREF(__pyx_num_0);
  __pyx_k8 = __pyx_num_0;
  __pyx_k9 = -1;
  __pyx_k10 = 0;
  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_CFG_INTBITSET_ENABLE_SANITY_CHECKS); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; goto __pyx_L1;}
  __pyx_k11 = __pyx_2;
  __pyx_2 = 0;
  __pyx_k12 = 0;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":645
 *         return self.bitset.trailing_bits != 0
 * 
 *     def extract_finite_list(self, int up_to=-1):             # <<<<<<<<<<<<<< 
 *         """Return a finite list of elements sufficient to be passed to intbitset
 *         constructor toghether with the proper value of trailing_bits in order
 */
  __pyx_k13 = -1;

  /* "/usr/portage/build/cds-invenio/src/intbitset.pyx":694
 *         return self.last
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<< 
 *         return self
 */
  return;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("intbitset");
}

static char *__pyx_filenames[] = {
  "intbitset.pyx",
};

/* Runtime support code */

static void __pyx_init_filenames(void) {
  __pyx_f = __pyx_filenames;
}

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed, char *name) {
    if (!type) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if ((none_allowed && obj == Py_None) || PyObject_TypeCheck(obj, type))
        return 1;
    PyErr_Format(PyExc_TypeError,
        "Argument '%s' has incorrect type (expected %s, got %s)",
        name, type->tp_name, obj->ob_type->tp_name);
    return 0;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list) {
    PyObject *__import__ = 0;
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    __import__ = PyObject_GetAttrString(__pyx_b, "__import__");
    if (!__import__)
        goto bad;
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    module = PyObject_CallFunction(__import__, "OOOO",
        name, global_dict, empty_dict, list);
bad:
    Py_XDECREF(empty_list);
    Py_XDECREF(__import__);
    Py_XDECREF(empty_dict);
    return module;
}

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    Py_XINCREF(type);
    Py_XINCREF(value);
    Py_XINCREF(tb);
    /* First, check the traceback argument, replacing None with NULL. */
    if (tb == Py_None) {
        Py_DECREF(tb);
        tb = 0;
    }
    else if (tb != NULL && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto raise_error;
    }
    /* Next, replace a missing value with None */
    if (value == NULL) {
        value = Py_None;
        Py_INCREF(value);
    }
    /* Next, repeatedly, replace a tuple exception with its first item */
    while (PyTuple_Check(type) && PyTuple_Size(type) > 0) {
        PyObject *tmp = type;
        type = PyTuple_GET_ITEM(type, 0);
        Py_INCREF(type);
        Py_DECREF(tmp);
    }
    if (PyString_Check(type)) {
        if (PyErr_Warn(PyExc_DeprecationWarning,
                "raising a string exception is deprecated"))
            goto raise_error;
    }
    else if (PyType_Check(type) || PyClass_Check(type))
        ; /*PyErr_NormalizeException(&type, &value, &tb);*/
    else {
        /* Raising an instance.  The value should be a dummy. */
        if (value != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        /* Normalize to raise <class>, <instance> */
        Py_DECREF(value);
        value = type;
        if (PyInstance_Check(type))
            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
        else
            type = (PyObject*) type->ob_type;
        Py_INCREF(type);
    }
    PyErr_Restore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}

static PyObject *__Pyx_GetExcValue(void) {
    PyObject *type = 0, *value = 0, *tb = 0;
    PyObject *result = 0;
    PyThreadState *tstate = PyThreadState_Get();
    PyErr_Fetch(&type, &value, &tb);
    PyErr_NormalizeException(&type, &value, &tb);
    if (PyErr_Occurred())
        goto bad;
    if (!value) {
        value = Py_None;
        Py_INCREF(value);
    }
    Py_XDECREF(tstate->exc_type);
    Py_XDECREF(tstate->exc_value);
    Py_XDECREF(tstate->exc_traceback);
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    result = value;
    Py_XINCREF(result);
    type = 0;
    value = 0;
    tb = 0;
bad:
    Py_XDECREF(type);
    Py_XDECREF(value);
    Py_XDECREF(tb);
    return result;
}

static void __Pyx_UnpackError(void) {
    PyErr_SetString(PyExc_ValueError, "unpack sequence of wrong size");
}

static PyObject *__Pyx_UnpackItem(PyObject *iter) {
    PyObject *item;
    if (!(item = PyIter_Next(iter))) {
        if (!PyErr_Occurred())
            __Pyx_UnpackError();
    }
    return item;
}

static int __Pyx_EndUnpack(PyObject *iter) {
    PyObject *item;
    if ((item = PyIter_Next(iter))) {
        Py_DECREF(item);
        __Pyx_UnpackError();
        return -1;
    }
    else if (!PyErr_Occurred())
        return 0;
    else
        return -1;
}

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t) {
    while (t->p) {
        *t->p = PyString_InternFromString(t->s);
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyObject *empty_tuple = 0;
    PyObject *empty_string = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    
    py_srcfile = PyString_FromString(__pyx_filename);
    if (!py_srcfile) goto bad;
    py_funcname = PyString_FromString(funcname);
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    empty_tuple = PyTuple_New(0);
    if (!empty_tuple) goto bad;
    empty_string = PyString_FromString("");
    if (!empty_string) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        empty_string, /*PyObject *code,*/
        empty_tuple,  /*PyObject *consts,*/
        empty_tuple,  /*PyObject *names,*/
        empty_tuple,  /*PyObject *varnames,*/
        empty_tuple,  /*PyObject *freevars,*/
        empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        empty_string  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_Get(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(empty_tuple);
    Py_XDECREF(empty_string);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}
